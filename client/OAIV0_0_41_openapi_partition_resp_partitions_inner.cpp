/**
 * Slurm REST API
 * API to access and control Slurm
 *
 * The version of the OpenAPI document: Slurm-24.05.5&openapi/dbv0.0.39&openapi/slurmctld&openapi/slurmdbd&openapi/v0.0.39
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIV0_0_41_openapi_partition_resp_partitions_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace hm:slurm:client {

OAIV0_0_41_openapi_partition_resp_partitions_inner::OAIV0_0_41_openapi_partition_resp_partitions_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIV0_0_41_openapi_partition_resp_partitions_inner::OAIV0_0_41_openapi_partition_resp_partitions_inner() {
    this->initializeModel();
}

OAIV0_0_41_openapi_partition_resp_partitions_inner::~OAIV0_0_41_openapi_partition_resp_partitions_inner() {}

void OAIV0_0_41_openapi_partition_resp_partitions_inner::initializeModel() {

    m_nodes_isSet = false;
    m_nodes_isValid = false;

    m_accounts_isSet = false;
    m_accounts_isValid = false;

    m_groups_isSet = false;
    m_groups_isValid = false;

    m_qos_isSet = false;
    m_qos_isValid = false;

    m_alternate_isSet = false;
    m_alternate_isValid = false;

    m_tres_isSet = false;
    m_tres_isValid = false;

    m_cluster_isSet = false;
    m_cluster_isValid = false;

    m_select_type_isSet = false;
    m_select_type_isValid = false;

    m_cpus_isSet = false;
    m_cpus_isValid = false;

    m_defaults_isSet = false;
    m_defaults_isValid = false;

    m_grace_time_isSet = false;
    m_grace_time_isValid = false;

    m_maximums_isSet = false;
    m_maximums_isValid = false;

    m_minimums_isSet = false;
    m_minimums_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_node_sets_isSet = false;
    m_node_sets_isValid = false;

    m_priority_isSet = false;
    m_priority_isValid = false;

    m_timeouts_isSet = false;
    m_timeouts_isValid = false;

    m_partition_isSet = false;
    m_partition_isValid = false;

    m_suspend_time_isSet = false;
    m_suspend_time_isValid = false;
}

void OAIV0_0_41_openapi_partition_resp_partitions_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIV0_0_41_openapi_partition_resp_partitions_inner::fromJsonObject(QJsonObject json) {

    m_nodes_isValid = ::hm:slurm:client::fromJsonValue(m_nodes, json[QString("nodes")]);
    m_nodes_isSet = !json[QString("nodes")].isNull() && m_nodes_isValid;

    m_accounts_isValid = ::hm:slurm:client::fromJsonValue(m_accounts, json[QString("accounts")]);
    m_accounts_isSet = !json[QString("accounts")].isNull() && m_accounts_isValid;

    m_groups_isValid = ::hm:slurm:client::fromJsonValue(m_groups, json[QString("groups")]);
    m_groups_isSet = !json[QString("groups")].isNull() && m_groups_isValid;

    m_qos_isValid = ::hm:slurm:client::fromJsonValue(m_qos, json[QString("qos")]);
    m_qos_isSet = !json[QString("qos")].isNull() && m_qos_isValid;

    m_alternate_isValid = ::hm:slurm:client::fromJsonValue(m_alternate, json[QString("alternate")]);
    m_alternate_isSet = !json[QString("alternate")].isNull() && m_alternate_isValid;

    m_tres_isValid = ::hm:slurm:client::fromJsonValue(m_tres, json[QString("tres")]);
    m_tres_isSet = !json[QString("tres")].isNull() && m_tres_isValid;

    m_cluster_isValid = ::hm:slurm:client::fromJsonValue(m_cluster, json[QString("cluster")]);
    m_cluster_isSet = !json[QString("cluster")].isNull() && m_cluster_isValid;

    m_select_type_isValid = ::hm:slurm:client::fromJsonValue(m_select_type, json[QString("select_type")]);
    m_select_type_isSet = !json[QString("select_type")].isNull() && m_select_type_isValid;

    m_cpus_isValid = ::hm:slurm:client::fromJsonValue(m_cpus, json[QString("cpus")]);
    m_cpus_isSet = !json[QString("cpus")].isNull() && m_cpus_isValid;

    m_defaults_isValid = ::hm:slurm:client::fromJsonValue(m_defaults, json[QString("defaults")]);
    m_defaults_isSet = !json[QString("defaults")].isNull() && m_defaults_isValid;

    m_grace_time_isValid = ::hm:slurm:client::fromJsonValue(m_grace_time, json[QString("grace_time")]);
    m_grace_time_isSet = !json[QString("grace_time")].isNull() && m_grace_time_isValid;

    m_maximums_isValid = ::hm:slurm:client::fromJsonValue(m_maximums, json[QString("maximums")]);
    m_maximums_isSet = !json[QString("maximums")].isNull() && m_maximums_isValid;

    m_minimums_isValid = ::hm:slurm:client::fromJsonValue(m_minimums, json[QString("minimums")]);
    m_minimums_isSet = !json[QString("minimums")].isNull() && m_minimums_isValid;

    m_name_isValid = ::hm:slurm:client::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_node_sets_isValid = ::hm:slurm:client::fromJsonValue(m_node_sets, json[QString("node_sets")]);
    m_node_sets_isSet = !json[QString("node_sets")].isNull() && m_node_sets_isValid;

    m_priority_isValid = ::hm:slurm:client::fromJsonValue(m_priority, json[QString("priority")]);
    m_priority_isSet = !json[QString("priority")].isNull() && m_priority_isValid;

    m_timeouts_isValid = ::hm:slurm:client::fromJsonValue(m_timeouts, json[QString("timeouts")]);
    m_timeouts_isSet = !json[QString("timeouts")].isNull() && m_timeouts_isValid;

    m_partition_isValid = ::hm:slurm:client::fromJsonValue(m_partition, json[QString("partition")]);
    m_partition_isSet = !json[QString("partition")].isNull() && m_partition_isValid;

    m_suspend_time_isValid = ::hm:slurm:client::fromJsonValue(m_suspend_time, json[QString("suspend_time")]);
    m_suspend_time_isSet = !json[QString("suspend_time")].isNull() && m_suspend_time_isValid;
}

QString OAIV0_0_41_openapi_partition_resp_partitions_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIV0_0_41_openapi_partition_resp_partitions_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_nodes.isSet()) {
        obj.insert(QString("nodes"), ::hm:slurm:client::toJsonValue(m_nodes));
    }
    if (m_accounts.isSet()) {
        obj.insert(QString("accounts"), ::hm:slurm:client::toJsonValue(m_accounts));
    }
    if (m_groups.isSet()) {
        obj.insert(QString("groups"), ::hm:slurm:client::toJsonValue(m_groups));
    }
    if (m_qos.isSet()) {
        obj.insert(QString("qos"), ::hm:slurm:client::toJsonValue(m_qos));
    }
    if (m_alternate_isSet) {
        obj.insert(QString("alternate"), ::hm:slurm:client::toJsonValue(m_alternate));
    }
    if (m_tres.isSet()) {
        obj.insert(QString("tres"), ::hm:slurm:client::toJsonValue(m_tres));
    }
    if (m_cluster_isSet) {
        obj.insert(QString("cluster"), ::hm:slurm:client::toJsonValue(m_cluster));
    }
    if (m_select_type.size() > 0) {
        obj.insert(QString("select_type"), ::hm:slurm:client::toJsonValue(m_select_type));
    }
    if (m_cpus.isSet()) {
        obj.insert(QString("cpus"), ::hm:slurm:client::toJsonValue(m_cpus));
    }
    if (m_defaults.isSet()) {
        obj.insert(QString("defaults"), ::hm:slurm:client::toJsonValue(m_defaults));
    }
    if (m_grace_time_isSet) {
        obj.insert(QString("grace_time"), ::hm:slurm:client::toJsonValue(m_grace_time));
    }
    if (m_maximums.isSet()) {
        obj.insert(QString("maximums"), ::hm:slurm:client::toJsonValue(m_maximums));
    }
    if (m_minimums.isSet()) {
        obj.insert(QString("minimums"), ::hm:slurm:client::toJsonValue(m_minimums));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::hm:slurm:client::toJsonValue(m_name));
    }
    if (m_node_sets_isSet) {
        obj.insert(QString("node_sets"), ::hm:slurm:client::toJsonValue(m_node_sets));
    }
    if (m_priority.isSet()) {
        obj.insert(QString("priority"), ::hm:slurm:client::toJsonValue(m_priority));
    }
    if (m_timeouts.isSet()) {
        obj.insert(QString("timeouts"), ::hm:slurm:client::toJsonValue(m_timeouts));
    }
    if (m_partition.isSet()) {
        obj.insert(QString("partition"), ::hm:slurm:client::toJsonValue(m_partition));
    }
    if (m_suspend_time.isSet()) {
        obj.insert(QString("suspend_time"), ::hm:slurm:client::toJsonValue(m_suspend_time));
    }
    return obj;
}

OAIV0_0_40_partition_info_nodes OAIV0_0_41_openapi_partition_resp_partitions_inner::getNodes() const {
    return m_nodes;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setNodes(const OAIV0_0_40_partition_info_nodes &nodes) {
    m_nodes = nodes;
    m_nodes_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_nodes_Set() const{
    return m_nodes_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_nodes_Valid() const{
    return m_nodes_isValid;
}

OAIV0_0_40_partition_info_accounts OAIV0_0_41_openapi_partition_resp_partitions_inner::getAccounts() const {
    return m_accounts;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setAccounts(const OAIV0_0_40_partition_info_accounts &accounts) {
    m_accounts = accounts;
    m_accounts_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_accounts_Set() const{
    return m_accounts_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_accounts_Valid() const{
    return m_accounts_isValid;
}

OAIV0_0_40_partition_info_groups OAIV0_0_41_openapi_partition_resp_partitions_inner::getGroups() const {
    return m_groups;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setGroups(const OAIV0_0_40_partition_info_groups &groups) {
    m_groups = groups;
    m_groups_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_groups_Set() const{
    return m_groups_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_groups_Valid() const{
    return m_groups_isValid;
}

OAIV0_0_40_partition_info_qos OAIV0_0_41_openapi_partition_resp_partitions_inner::getQos() const {
    return m_qos;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setQos(const OAIV0_0_40_partition_info_qos &qos) {
    m_qos = qos;
    m_qos_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_qos_Set() const{
    return m_qos_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_qos_Valid() const{
    return m_qos_isValid;
}

QString OAIV0_0_41_openapi_partition_resp_partitions_inner::getAlternate() const {
    return m_alternate;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setAlternate(const QString &alternate) {
    m_alternate = alternate;
    m_alternate_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_alternate_Set() const{
    return m_alternate_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_alternate_Valid() const{
    return m_alternate_isValid;
}

OAIV0_0_40_partition_info_tres OAIV0_0_41_openapi_partition_resp_partitions_inner::getTres() const {
    return m_tres;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setTres(const OAIV0_0_40_partition_info_tres &tres) {
    m_tres = tres;
    m_tres_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_tres_Set() const{
    return m_tres_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_tres_Valid() const{
    return m_tres_isValid;
}

QString OAIV0_0_41_openapi_partition_resp_partitions_inner::getCluster() const {
    return m_cluster;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setCluster(const QString &cluster) {
    m_cluster = cluster;
    m_cluster_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_cluster_Set() const{
    return m_cluster_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_cluster_Valid() const{
    return m_cluster_isValid;
}

QList<QString> OAIV0_0_41_openapi_partition_resp_partitions_inner::getSelectType() const {
    return m_select_type;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setSelectType(const QList<QString> &select_type) {
    m_select_type = select_type;
    m_select_type_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_select_type_Set() const{
    return m_select_type_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_select_type_Valid() const{
    return m_select_type_isValid;
}

OAIV0_0_40_partition_info_cpus OAIV0_0_41_openapi_partition_resp_partitions_inner::getCpus() const {
    return m_cpus;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setCpus(const OAIV0_0_40_partition_info_cpus &cpus) {
    m_cpus = cpus;
    m_cpus_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_cpus_Set() const{
    return m_cpus_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_cpus_Valid() const{
    return m_cpus_isValid;
}

OAIV0_0_41_openapi_partition_resp_partitions_inner_defaults OAIV0_0_41_openapi_partition_resp_partitions_inner::getDefaults() const {
    return m_defaults;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setDefaults(const OAIV0_0_41_openapi_partition_resp_partitions_inner_defaults &defaults) {
    m_defaults = defaults;
    m_defaults_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_defaults_Set() const{
    return m_defaults_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_defaults_Valid() const{
    return m_defaults_isValid;
}

qint32 OAIV0_0_41_openapi_partition_resp_partitions_inner::getGraceTime() const {
    return m_grace_time;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setGraceTime(const qint32 &grace_time) {
    m_grace_time = grace_time;
    m_grace_time_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_grace_time_Set() const{
    return m_grace_time_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_grace_time_Valid() const{
    return m_grace_time_isValid;
}

OAIV0_0_41_openapi_partition_resp_partitions_inner_maximums OAIV0_0_41_openapi_partition_resp_partitions_inner::getMaximums() const {
    return m_maximums;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setMaximums(const OAIV0_0_41_openapi_partition_resp_partitions_inner_maximums &maximums) {
    m_maximums = maximums;
    m_maximums_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_maximums_Set() const{
    return m_maximums_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_maximums_Valid() const{
    return m_maximums_isValid;
}

OAIV0_0_40_partition_info_minimums OAIV0_0_41_openapi_partition_resp_partitions_inner::getMinimums() const {
    return m_minimums;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setMinimums(const OAIV0_0_40_partition_info_minimums &minimums) {
    m_minimums = minimums;
    m_minimums_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_minimums_Set() const{
    return m_minimums_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_minimums_Valid() const{
    return m_minimums_isValid;
}

QString OAIV0_0_41_openapi_partition_resp_partitions_inner::getName() const {
    return m_name;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_name_Set() const{
    return m_name_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIV0_0_41_openapi_partition_resp_partitions_inner::getNodeSets() const {
    return m_node_sets;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setNodeSets(const QString &node_sets) {
    m_node_sets = node_sets;
    m_node_sets_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_node_sets_Set() const{
    return m_node_sets_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_node_sets_Valid() const{
    return m_node_sets_isValid;
}

OAIV0_0_40_partition_info_priority OAIV0_0_41_openapi_partition_resp_partitions_inner::getPriority() const {
    return m_priority;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setPriority(const OAIV0_0_40_partition_info_priority &priority) {
    m_priority = priority;
    m_priority_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_priority_Set() const{
    return m_priority_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_priority_Valid() const{
    return m_priority_isValid;
}

OAIV0_0_41_openapi_partition_resp_partitions_inner_timeouts OAIV0_0_41_openapi_partition_resp_partitions_inner::getTimeouts() const {
    return m_timeouts;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setTimeouts(const OAIV0_0_41_openapi_partition_resp_partitions_inner_timeouts &timeouts) {
    m_timeouts = timeouts;
    m_timeouts_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_timeouts_Set() const{
    return m_timeouts_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_timeouts_Valid() const{
    return m_timeouts_isValid;
}

OAIV0_0_40_partition_info_partition OAIV0_0_41_openapi_partition_resp_partitions_inner::getPartition() const {
    return m_partition;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setPartition(const OAIV0_0_40_partition_info_partition &partition) {
    m_partition = partition;
    m_partition_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_partition_Set() const{
    return m_partition_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_partition_Valid() const{
    return m_partition_isValid;
}

OAIV0_0_41_openapi_partition_resp_partitions_inner_suspend_time OAIV0_0_41_openapi_partition_resp_partitions_inner::getSuspendTime() const {
    return m_suspend_time;
}
void OAIV0_0_41_openapi_partition_resp_partitions_inner::setSuspendTime(const OAIV0_0_41_openapi_partition_resp_partitions_inner_suspend_time &suspend_time) {
    m_suspend_time = suspend_time;
    m_suspend_time_isSet = true;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_suspend_time_Set() const{
    return m_suspend_time_isSet;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::is_suspend_time_Valid() const{
    return m_suspend_time_isValid;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_nodes.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_accounts.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_groups.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_qos.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_alternate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_select_type.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpus.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_defaults.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_grace_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximums.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimums.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_node_sets_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_priority.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeouts.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_partition.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_suspend_time.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIV0_0_41_openapi_partition_resp_partitions_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace hm:slurm:client
