/**
 * Slurm REST API
 * API to access and control Slurm
 *
 * The version of the OpenAPI document: Slurm-24.05.5&openapi/dbv0.0.39&openapi/slurmctld&openapi/slurmdbd&openapi/v0.0.39
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIV0_0_39_job_info.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace hm:slurm:client {

OAIV0_0_39_job_info::OAIV0_0_39_job_info(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIV0_0_39_job_info::OAIV0_0_39_job_info() {
    this->initializeModel();
}

OAIV0_0_39_job_info::~OAIV0_0_39_job_info() {}

void OAIV0_0_39_job_info::initializeModel() {

    m_account_isSet = false;
    m_account_isValid = false;

    m_accrue_time_isSet = false;
    m_accrue_time_isValid = false;

    m_admin_comment_isSet = false;
    m_admin_comment_isValid = false;

    m_allocating_node_isSet = false;
    m_allocating_node_isValid = false;

    m_array_job_id_isSet = false;
    m_array_job_id_isValid = false;

    m_array_task_id_isSet = false;
    m_array_task_id_isValid = false;

    m_array_max_tasks_isSet = false;
    m_array_max_tasks_isValid = false;

    m_array_task_string_isSet = false;
    m_array_task_string_isValid = false;

    m_association_id_isSet = false;
    m_association_id_isValid = false;

    m_batch_features_isSet = false;
    m_batch_features_isValid = false;

    m_batch_flag_isSet = false;
    m_batch_flag_isValid = false;

    m_batch_host_isSet = false;
    m_batch_host_isValid = false;

    m_flags_isSet = false;
    m_flags_isValid = false;

    m_burst_buffer_isSet = false;
    m_burst_buffer_isValid = false;

    m_burst_buffer_state_isSet = false;
    m_burst_buffer_state_isValid = false;

    m_cluster_isSet = false;
    m_cluster_isValid = false;

    m_cluster_features_isSet = false;
    m_cluster_features_isValid = false;

    m_command_isSet = false;
    m_command_isValid = false;

    m_comment_isSet = false;
    m_comment_isValid = false;

    m_container_isSet = false;
    m_container_isValid = false;

    m_container_id_isSet = false;
    m_container_id_isValid = false;

    m_contiguous_isSet = false;
    m_contiguous_isValid = false;

    m_core_spec_isSet = false;
    m_core_spec_isValid = false;

    m_thread_spec_isSet = false;
    m_thread_spec_isValid = false;

    m_cores_per_socket_isSet = false;
    m_cores_per_socket_isValid = false;

    m_billable_tres_isSet = false;
    m_billable_tres_isValid = false;

    m_cpus_per_task_isSet = false;
    m_cpus_per_task_isValid = false;

    m_cpu_frequency_minimum_isSet = false;
    m_cpu_frequency_minimum_isValid = false;

    m_cpu_frequency_maximum_isSet = false;
    m_cpu_frequency_maximum_isValid = false;

    m_cpu_frequency_governor_isSet = false;
    m_cpu_frequency_governor_isValid = false;

    m_cpus_per_tres_isSet = false;
    m_cpus_per_tres_isValid = false;

    m_cron_isSet = false;
    m_cron_isValid = false;

    m_deadline_isSet = false;
    m_deadline_isValid = false;

    m_delay_boot_isSet = false;
    m_delay_boot_isValid = false;

    m_dependency_isSet = false;
    m_dependency_isValid = false;

    m_derived_exit_code_isSet = false;
    m_derived_exit_code_isValid = false;

    m_eligible_time_isSet = false;
    m_eligible_time_isValid = false;

    m_end_time_isSet = false;
    m_end_time_isValid = false;

    m_excluded_nodes_isSet = false;
    m_excluded_nodes_isValid = false;

    m_exit_code_isSet = false;
    m_exit_code_isValid = false;

    m_extra_isSet = false;
    m_extra_isValid = false;

    m_failed_node_isSet = false;
    m_failed_node_isValid = false;

    m_features_isSet = false;
    m_features_isValid = false;

    m_federation_origin_isSet = false;
    m_federation_origin_isValid = false;

    m_federation_siblings_active_isSet = false;
    m_federation_siblings_active_isValid = false;

    m_federation_siblings_viable_isSet = false;
    m_federation_siblings_viable_isValid = false;

    m_gres_detail_isSet = false;
    m_gres_detail_isValid = false;

    m_group_id_isSet = false;
    m_group_id_isValid = false;

    m_group_name_isSet = false;
    m_group_name_isValid = false;

    m_het_job_id_isSet = false;
    m_het_job_id_isValid = false;

    m_het_job_id_set_isSet = false;
    m_het_job_id_set_isValid = false;

    m_het_job_offset_isSet = false;
    m_het_job_offset_isValid = false;

    m_job_id_isSet = false;
    m_job_id_isValid = false;

    m_job_resources_isSet = false;
    m_job_resources_isValid = false;

    m_job_size_str_isSet = false;
    m_job_size_str_isValid = false;

    m_job_state_isSet = false;
    m_job_state_isValid = false;

    m_last_sched_evaluation_isSet = false;
    m_last_sched_evaluation_isValid = false;

    m_licenses_isSet = false;
    m_licenses_isValid = false;

    m_mail_type_isSet = false;
    m_mail_type_isValid = false;

    m_mail_user_isSet = false;
    m_mail_user_isValid = false;

    m_max_cpus_isSet = false;
    m_max_cpus_isValid = false;

    m_max_nodes_isSet = false;
    m_max_nodes_isValid = false;

    m_mcs_label_isSet = false;
    m_mcs_label_isValid = false;

    m_memory_per_tres_isSet = false;
    m_memory_per_tres_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_network_isSet = false;
    m_network_isValid = false;

    m_nodes_isSet = false;
    m_nodes_isValid = false;

    m_nice_isSet = false;
    m_nice_isValid = false;

    m_tasks_per_core_isSet = false;
    m_tasks_per_core_isValid = false;

    m_tasks_per_tres_isSet = false;
    m_tasks_per_tres_isValid = false;

    m_tasks_per_node_isSet = false;
    m_tasks_per_node_isValid = false;

    m_tasks_per_socket_isSet = false;
    m_tasks_per_socket_isValid = false;

    m_tasks_per_board_isSet = false;
    m_tasks_per_board_isValid = false;

    m_cpus_isSet = false;
    m_cpus_isValid = false;

    m_node_count_isSet = false;
    m_node_count_isValid = false;

    m_tasks_isSet = false;
    m_tasks_isValid = false;

    m_partition_isSet = false;
    m_partition_isValid = false;

    m_prefer_isSet = false;
    m_prefer_isValid = false;

    m_memory_per_cpu_isSet = false;
    m_memory_per_cpu_isValid = false;

    m_memory_per_node_isSet = false;
    m_memory_per_node_isValid = false;

    m_minimum_cpus_per_node_isSet = false;
    m_minimum_cpus_per_node_isValid = false;

    m_minimum_tmp_disk_per_node_isSet = false;
    m_minimum_tmp_disk_per_node_isValid = false;

    m_power_isSet = false;
    m_power_isValid = false;

    m_preempt_time_isSet = false;
    m_preempt_time_isValid = false;

    m_preemptable_time_isSet = false;
    m_preemptable_time_isValid = false;

    m_pre_sus_time_isSet = false;
    m_pre_sus_time_isValid = false;

    m_hold_isSet = false;
    m_hold_isValid = false;

    m_priority_isSet = false;
    m_priority_isValid = false;

    m_profile_isSet = false;
    m_profile_isValid = false;

    m_qos_isSet = false;
    m_qos_isValid = false;

    m_reboot_isSet = false;
    m_reboot_isValid = false;

    m_required_nodes_isSet = false;
    m_required_nodes_isValid = false;

    m_minimum_switches_isSet = false;
    m_minimum_switches_isValid = false;

    m_requeue_isSet = false;
    m_requeue_isValid = false;

    m_resize_time_isSet = false;
    m_resize_time_isValid = false;

    m_restart_cnt_isSet = false;
    m_restart_cnt_isValid = false;

    m_resv_name_isSet = false;
    m_resv_name_isValid = false;

    m_scheduled_nodes_isSet = false;
    m_scheduled_nodes_isValid = false;

    m_selinux_context_isSet = false;
    m_selinux_context_isValid = false;

    m_shared_isSet = false;
    m_shared_isValid = false;

    m_exclusive_isSet = false;
    m_exclusive_isValid = false;

    m_oversubscribe_isSet = false;
    m_oversubscribe_isValid = false;

    m_show_flags_isSet = false;
    m_show_flags_isValid = false;

    m_sockets_per_board_isSet = false;
    m_sockets_per_board_isValid = false;

    m_sockets_per_node_isSet = false;
    m_sockets_per_node_isValid = false;

    m_start_time_isSet = false;
    m_start_time_isValid = false;

    m_state_description_isSet = false;
    m_state_description_isValid = false;

    m_state_reason_isSet = false;
    m_state_reason_isValid = false;

    m_standard_error_isSet = false;
    m_standard_error_isValid = false;

    m_standard_input_isSet = false;
    m_standard_input_isValid = false;

    m_standard_output_isSet = false;
    m_standard_output_isValid = false;

    m_submit_time_isSet = false;
    m_submit_time_isValid = false;

    m_suspend_time_isSet = false;
    m_suspend_time_isValid = false;

    m_system_comment_isSet = false;
    m_system_comment_isValid = false;

    m_time_limit_isSet = false;
    m_time_limit_isValid = false;

    m_time_minimum_isSet = false;
    m_time_minimum_isValid = false;

    m_threads_per_core_isSet = false;
    m_threads_per_core_isValid = false;

    m_tres_bind_isSet = false;
    m_tres_bind_isValid = false;

    m_tres_freq_isSet = false;
    m_tres_freq_isValid = false;

    m_tres_per_job_isSet = false;
    m_tres_per_job_isValid = false;

    m_tres_per_node_isSet = false;
    m_tres_per_node_isValid = false;

    m_tres_per_socket_isSet = false;
    m_tres_per_socket_isValid = false;

    m_tres_per_task_isSet = false;
    m_tres_per_task_isValid = false;

    m_tres_req_str_isSet = false;
    m_tres_req_str_isValid = false;

    m_tres_alloc_str_isSet = false;
    m_tres_alloc_str_isValid = false;

    m_user_id_isSet = false;
    m_user_id_isValid = false;

    m_user_name_isSet = false;
    m_user_name_isValid = false;

    m_maximum_switch_wait_time_isSet = false;
    m_maximum_switch_wait_time_isValid = false;

    m_wckey_isSet = false;
    m_wckey_isValid = false;

    m_current_working_directory_isSet = false;
    m_current_working_directory_isValid = false;
}

void OAIV0_0_39_job_info::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIV0_0_39_job_info::fromJsonObject(QJsonObject json) {

    m_account_isValid = ::hm:slurm:client::fromJsonValue(m_account, json[QString("account")]);
    m_account_isSet = !json[QString("account")].isNull() && m_account_isValid;

    m_accrue_time_isValid = ::hm:slurm:client::fromJsonValue(m_accrue_time, json[QString("accrue_time")]);
    m_accrue_time_isSet = !json[QString("accrue_time")].isNull() && m_accrue_time_isValid;

    m_admin_comment_isValid = ::hm:slurm:client::fromJsonValue(m_admin_comment, json[QString("admin_comment")]);
    m_admin_comment_isSet = !json[QString("admin_comment")].isNull() && m_admin_comment_isValid;

    m_allocating_node_isValid = ::hm:slurm:client::fromJsonValue(m_allocating_node, json[QString("allocating_node")]);
    m_allocating_node_isSet = !json[QString("allocating_node")].isNull() && m_allocating_node_isValid;

    m_array_job_id_isValid = ::hm:slurm:client::fromJsonValue(m_array_job_id, json[QString("array_job_id")]);
    m_array_job_id_isSet = !json[QString("array_job_id")].isNull() && m_array_job_id_isValid;

    m_array_task_id_isValid = ::hm:slurm:client::fromJsonValue(m_array_task_id, json[QString("array_task_id")]);
    m_array_task_id_isSet = !json[QString("array_task_id")].isNull() && m_array_task_id_isValid;

    m_array_max_tasks_isValid = ::hm:slurm:client::fromJsonValue(m_array_max_tasks, json[QString("array_max_tasks")]);
    m_array_max_tasks_isSet = !json[QString("array_max_tasks")].isNull() && m_array_max_tasks_isValid;

    m_array_task_string_isValid = ::hm:slurm:client::fromJsonValue(m_array_task_string, json[QString("array_task_string")]);
    m_array_task_string_isSet = !json[QString("array_task_string")].isNull() && m_array_task_string_isValid;

    m_association_id_isValid = ::hm:slurm:client::fromJsonValue(m_association_id, json[QString("association_id")]);
    m_association_id_isSet = !json[QString("association_id")].isNull() && m_association_id_isValid;

    m_batch_features_isValid = ::hm:slurm:client::fromJsonValue(m_batch_features, json[QString("batch_features")]);
    m_batch_features_isSet = !json[QString("batch_features")].isNull() && m_batch_features_isValid;

    m_batch_flag_isValid = ::hm:slurm:client::fromJsonValue(m_batch_flag, json[QString("batch_flag")]);
    m_batch_flag_isSet = !json[QString("batch_flag")].isNull() && m_batch_flag_isValid;

    m_batch_host_isValid = ::hm:slurm:client::fromJsonValue(m_batch_host, json[QString("batch_host")]);
    m_batch_host_isSet = !json[QString("batch_host")].isNull() && m_batch_host_isValid;

    m_flags_isValid = ::hm:slurm:client::fromJsonValue(m_flags, json[QString("flags")]);
    m_flags_isSet = !json[QString("flags")].isNull() && m_flags_isValid;

    m_burst_buffer_isValid = ::hm:slurm:client::fromJsonValue(m_burst_buffer, json[QString("burst_buffer")]);
    m_burst_buffer_isSet = !json[QString("burst_buffer")].isNull() && m_burst_buffer_isValid;

    m_burst_buffer_state_isValid = ::hm:slurm:client::fromJsonValue(m_burst_buffer_state, json[QString("burst_buffer_state")]);
    m_burst_buffer_state_isSet = !json[QString("burst_buffer_state")].isNull() && m_burst_buffer_state_isValid;

    m_cluster_isValid = ::hm:slurm:client::fromJsonValue(m_cluster, json[QString("cluster")]);
    m_cluster_isSet = !json[QString("cluster")].isNull() && m_cluster_isValid;

    m_cluster_features_isValid = ::hm:slurm:client::fromJsonValue(m_cluster_features, json[QString("cluster_features")]);
    m_cluster_features_isSet = !json[QString("cluster_features")].isNull() && m_cluster_features_isValid;

    m_command_isValid = ::hm:slurm:client::fromJsonValue(m_command, json[QString("command")]);
    m_command_isSet = !json[QString("command")].isNull() && m_command_isValid;

    m_comment_isValid = ::hm:slurm:client::fromJsonValue(m_comment, json[QString("comment")]);
    m_comment_isSet = !json[QString("comment")].isNull() && m_comment_isValid;

    m_container_isValid = ::hm:slurm:client::fromJsonValue(m_container, json[QString("container")]);
    m_container_isSet = !json[QString("container")].isNull() && m_container_isValid;

    m_container_id_isValid = ::hm:slurm:client::fromJsonValue(m_container_id, json[QString("container_id")]);
    m_container_id_isSet = !json[QString("container_id")].isNull() && m_container_id_isValid;

    m_contiguous_isValid = ::hm:slurm:client::fromJsonValue(m_contiguous, json[QString("contiguous")]);
    m_contiguous_isSet = !json[QString("contiguous")].isNull() && m_contiguous_isValid;

    m_core_spec_isValid = ::hm:slurm:client::fromJsonValue(m_core_spec, json[QString("core_spec")]);
    m_core_spec_isSet = !json[QString("core_spec")].isNull() && m_core_spec_isValid;

    m_thread_spec_isValid = ::hm:slurm:client::fromJsonValue(m_thread_spec, json[QString("thread_spec")]);
    m_thread_spec_isSet = !json[QString("thread_spec")].isNull() && m_thread_spec_isValid;

    m_cores_per_socket_isValid = ::hm:slurm:client::fromJsonValue(m_cores_per_socket, json[QString("cores_per_socket")]);
    m_cores_per_socket_isSet = !json[QString("cores_per_socket")].isNull() && m_cores_per_socket_isValid;

    m_billable_tres_isValid = ::hm:slurm:client::fromJsonValue(m_billable_tres, json[QString("billable_tres")]);
    m_billable_tres_isSet = !json[QString("billable_tres")].isNull() && m_billable_tres_isValid;

    m_cpus_per_task_isValid = ::hm:slurm:client::fromJsonValue(m_cpus_per_task, json[QString("cpus_per_task")]);
    m_cpus_per_task_isSet = !json[QString("cpus_per_task")].isNull() && m_cpus_per_task_isValid;

    m_cpu_frequency_minimum_isValid = ::hm:slurm:client::fromJsonValue(m_cpu_frequency_minimum, json[QString("cpu_frequency_minimum")]);
    m_cpu_frequency_minimum_isSet = !json[QString("cpu_frequency_minimum")].isNull() && m_cpu_frequency_minimum_isValid;

    m_cpu_frequency_maximum_isValid = ::hm:slurm:client::fromJsonValue(m_cpu_frequency_maximum, json[QString("cpu_frequency_maximum")]);
    m_cpu_frequency_maximum_isSet = !json[QString("cpu_frequency_maximum")].isNull() && m_cpu_frequency_maximum_isValid;

    m_cpu_frequency_governor_isValid = ::hm:slurm:client::fromJsonValue(m_cpu_frequency_governor, json[QString("cpu_frequency_governor")]);
    m_cpu_frequency_governor_isSet = !json[QString("cpu_frequency_governor")].isNull() && m_cpu_frequency_governor_isValid;

    m_cpus_per_tres_isValid = ::hm:slurm:client::fromJsonValue(m_cpus_per_tres, json[QString("cpus_per_tres")]);
    m_cpus_per_tres_isSet = !json[QString("cpus_per_tres")].isNull() && m_cpus_per_tres_isValid;

    m_cron_isValid = ::hm:slurm:client::fromJsonValue(m_cron, json[QString("cron")]);
    m_cron_isSet = !json[QString("cron")].isNull() && m_cron_isValid;

    m_deadline_isValid = ::hm:slurm:client::fromJsonValue(m_deadline, json[QString("deadline")]);
    m_deadline_isSet = !json[QString("deadline")].isNull() && m_deadline_isValid;

    m_delay_boot_isValid = ::hm:slurm:client::fromJsonValue(m_delay_boot, json[QString("delay_boot")]);
    m_delay_boot_isSet = !json[QString("delay_boot")].isNull() && m_delay_boot_isValid;

    m_dependency_isValid = ::hm:slurm:client::fromJsonValue(m_dependency, json[QString("dependency")]);
    m_dependency_isSet = !json[QString("dependency")].isNull() && m_dependency_isValid;

    m_derived_exit_code_isValid = ::hm:slurm:client::fromJsonValue(m_derived_exit_code, json[QString("derived_exit_code")]);
    m_derived_exit_code_isSet = !json[QString("derived_exit_code")].isNull() && m_derived_exit_code_isValid;

    m_eligible_time_isValid = ::hm:slurm:client::fromJsonValue(m_eligible_time, json[QString("eligible_time")]);
    m_eligible_time_isSet = !json[QString("eligible_time")].isNull() && m_eligible_time_isValid;

    m_end_time_isValid = ::hm:slurm:client::fromJsonValue(m_end_time, json[QString("end_time")]);
    m_end_time_isSet = !json[QString("end_time")].isNull() && m_end_time_isValid;

    m_excluded_nodes_isValid = ::hm:slurm:client::fromJsonValue(m_excluded_nodes, json[QString("excluded_nodes")]);
    m_excluded_nodes_isSet = !json[QString("excluded_nodes")].isNull() && m_excluded_nodes_isValid;

    m_exit_code_isValid = ::hm:slurm:client::fromJsonValue(m_exit_code, json[QString("exit_code")]);
    m_exit_code_isSet = !json[QString("exit_code")].isNull() && m_exit_code_isValid;

    m_extra_isValid = ::hm:slurm:client::fromJsonValue(m_extra, json[QString("extra")]);
    m_extra_isSet = !json[QString("extra")].isNull() && m_extra_isValid;

    m_failed_node_isValid = ::hm:slurm:client::fromJsonValue(m_failed_node, json[QString("failed_node")]);
    m_failed_node_isSet = !json[QString("failed_node")].isNull() && m_failed_node_isValid;

    m_features_isValid = ::hm:slurm:client::fromJsonValue(m_features, json[QString("features")]);
    m_features_isSet = !json[QString("features")].isNull() && m_features_isValid;

    m_federation_origin_isValid = ::hm:slurm:client::fromJsonValue(m_federation_origin, json[QString("federation_origin")]);
    m_federation_origin_isSet = !json[QString("federation_origin")].isNull() && m_federation_origin_isValid;

    m_federation_siblings_active_isValid = ::hm:slurm:client::fromJsonValue(m_federation_siblings_active, json[QString("federation_siblings_active")]);
    m_federation_siblings_active_isSet = !json[QString("federation_siblings_active")].isNull() && m_federation_siblings_active_isValid;

    m_federation_siblings_viable_isValid = ::hm:slurm:client::fromJsonValue(m_federation_siblings_viable, json[QString("federation_siblings_viable")]);
    m_federation_siblings_viable_isSet = !json[QString("federation_siblings_viable")].isNull() && m_federation_siblings_viable_isValid;

    m_gres_detail_isValid = ::hm:slurm:client::fromJsonValue(m_gres_detail, json[QString("gres_detail")]);
    m_gres_detail_isSet = !json[QString("gres_detail")].isNull() && m_gres_detail_isValid;

    m_group_id_isValid = ::hm:slurm:client::fromJsonValue(m_group_id, json[QString("group_id")]);
    m_group_id_isSet = !json[QString("group_id")].isNull() && m_group_id_isValid;

    m_group_name_isValid = ::hm:slurm:client::fromJsonValue(m_group_name, json[QString("group_name")]);
    m_group_name_isSet = !json[QString("group_name")].isNull() && m_group_name_isValid;

    m_het_job_id_isValid = ::hm:slurm:client::fromJsonValue(m_het_job_id, json[QString("het_job_id")]);
    m_het_job_id_isSet = !json[QString("het_job_id")].isNull() && m_het_job_id_isValid;

    m_het_job_id_set_isValid = ::hm:slurm:client::fromJsonValue(m_het_job_id_set, json[QString("het_job_id_set")]);
    m_het_job_id_set_isSet = !json[QString("het_job_id_set")].isNull() && m_het_job_id_set_isValid;

    m_het_job_offset_isValid = ::hm:slurm:client::fromJsonValue(m_het_job_offset, json[QString("het_job_offset")]);
    m_het_job_offset_isSet = !json[QString("het_job_offset")].isNull() && m_het_job_offset_isValid;

    m_job_id_isValid = ::hm:slurm:client::fromJsonValue(m_job_id, json[QString("job_id")]);
    m_job_id_isSet = !json[QString("job_id")].isNull() && m_job_id_isValid;

    m_job_resources_isValid = ::hm:slurm:client::fromJsonValue(m_job_resources, json[QString("job_resources")]);
    m_job_resources_isSet = !json[QString("job_resources")].isNull() && m_job_resources_isValid;

    m_job_size_str_isValid = ::hm:slurm:client::fromJsonValue(m_job_size_str, json[QString("job_size_str")]);
    m_job_size_str_isSet = !json[QString("job_size_str")].isNull() && m_job_size_str_isValid;

    m_job_state_isValid = ::hm:slurm:client::fromJsonValue(m_job_state, json[QString("job_state")]);
    m_job_state_isSet = !json[QString("job_state")].isNull() && m_job_state_isValid;

    m_last_sched_evaluation_isValid = ::hm:slurm:client::fromJsonValue(m_last_sched_evaluation, json[QString("last_sched_evaluation")]);
    m_last_sched_evaluation_isSet = !json[QString("last_sched_evaluation")].isNull() && m_last_sched_evaluation_isValid;

    m_licenses_isValid = ::hm:slurm:client::fromJsonValue(m_licenses, json[QString("licenses")]);
    m_licenses_isSet = !json[QString("licenses")].isNull() && m_licenses_isValid;

    m_mail_type_isValid = ::hm:slurm:client::fromJsonValue(m_mail_type, json[QString("mail_type")]);
    m_mail_type_isSet = !json[QString("mail_type")].isNull() && m_mail_type_isValid;

    m_mail_user_isValid = ::hm:slurm:client::fromJsonValue(m_mail_user, json[QString("mail_user")]);
    m_mail_user_isSet = !json[QString("mail_user")].isNull() && m_mail_user_isValid;

    m_max_cpus_isValid = ::hm:slurm:client::fromJsonValue(m_max_cpus, json[QString("max_cpus")]);
    m_max_cpus_isSet = !json[QString("max_cpus")].isNull() && m_max_cpus_isValid;

    m_max_nodes_isValid = ::hm:slurm:client::fromJsonValue(m_max_nodes, json[QString("max_nodes")]);
    m_max_nodes_isSet = !json[QString("max_nodes")].isNull() && m_max_nodes_isValid;

    m_mcs_label_isValid = ::hm:slurm:client::fromJsonValue(m_mcs_label, json[QString("mcs_label")]);
    m_mcs_label_isSet = !json[QString("mcs_label")].isNull() && m_mcs_label_isValid;

    m_memory_per_tres_isValid = ::hm:slurm:client::fromJsonValue(m_memory_per_tres, json[QString("memory_per_tres")]);
    m_memory_per_tres_isSet = !json[QString("memory_per_tres")].isNull() && m_memory_per_tres_isValid;

    m_name_isValid = ::hm:slurm:client::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_network_isValid = ::hm:slurm:client::fromJsonValue(m_network, json[QString("network")]);
    m_network_isSet = !json[QString("network")].isNull() && m_network_isValid;

    m_nodes_isValid = ::hm:slurm:client::fromJsonValue(m_nodes, json[QString("nodes")]);
    m_nodes_isSet = !json[QString("nodes")].isNull() && m_nodes_isValid;

    m_nice_isValid = ::hm:slurm:client::fromJsonValue(m_nice, json[QString("nice")]);
    m_nice_isSet = !json[QString("nice")].isNull() && m_nice_isValid;

    m_tasks_per_core_isValid = ::hm:slurm:client::fromJsonValue(m_tasks_per_core, json[QString("tasks_per_core")]);
    m_tasks_per_core_isSet = !json[QString("tasks_per_core")].isNull() && m_tasks_per_core_isValid;

    m_tasks_per_tres_isValid = ::hm:slurm:client::fromJsonValue(m_tasks_per_tres, json[QString("tasks_per_tres")]);
    m_tasks_per_tres_isSet = !json[QString("tasks_per_tres")].isNull() && m_tasks_per_tres_isValid;

    m_tasks_per_node_isValid = ::hm:slurm:client::fromJsonValue(m_tasks_per_node, json[QString("tasks_per_node")]);
    m_tasks_per_node_isSet = !json[QString("tasks_per_node")].isNull() && m_tasks_per_node_isValid;

    m_tasks_per_socket_isValid = ::hm:slurm:client::fromJsonValue(m_tasks_per_socket, json[QString("tasks_per_socket")]);
    m_tasks_per_socket_isSet = !json[QString("tasks_per_socket")].isNull() && m_tasks_per_socket_isValid;

    m_tasks_per_board_isValid = ::hm:slurm:client::fromJsonValue(m_tasks_per_board, json[QString("tasks_per_board")]);
    m_tasks_per_board_isSet = !json[QString("tasks_per_board")].isNull() && m_tasks_per_board_isValid;

    m_cpus_isValid = ::hm:slurm:client::fromJsonValue(m_cpus, json[QString("cpus")]);
    m_cpus_isSet = !json[QString("cpus")].isNull() && m_cpus_isValid;

    m_node_count_isValid = ::hm:slurm:client::fromJsonValue(m_node_count, json[QString("node_count")]);
    m_node_count_isSet = !json[QString("node_count")].isNull() && m_node_count_isValid;

    m_tasks_isValid = ::hm:slurm:client::fromJsonValue(m_tasks, json[QString("tasks")]);
    m_tasks_isSet = !json[QString("tasks")].isNull() && m_tasks_isValid;

    m_partition_isValid = ::hm:slurm:client::fromJsonValue(m_partition, json[QString("partition")]);
    m_partition_isSet = !json[QString("partition")].isNull() && m_partition_isValid;

    m_prefer_isValid = ::hm:slurm:client::fromJsonValue(m_prefer, json[QString("prefer")]);
    m_prefer_isSet = !json[QString("prefer")].isNull() && m_prefer_isValid;

    m_memory_per_cpu_isValid = ::hm:slurm:client::fromJsonValue(m_memory_per_cpu, json[QString("memory_per_cpu")]);
    m_memory_per_cpu_isSet = !json[QString("memory_per_cpu")].isNull() && m_memory_per_cpu_isValid;

    m_memory_per_node_isValid = ::hm:slurm:client::fromJsonValue(m_memory_per_node, json[QString("memory_per_node")]);
    m_memory_per_node_isSet = !json[QString("memory_per_node")].isNull() && m_memory_per_node_isValid;

    m_minimum_cpus_per_node_isValid = ::hm:slurm:client::fromJsonValue(m_minimum_cpus_per_node, json[QString("minimum_cpus_per_node")]);
    m_minimum_cpus_per_node_isSet = !json[QString("minimum_cpus_per_node")].isNull() && m_minimum_cpus_per_node_isValid;

    m_minimum_tmp_disk_per_node_isValid = ::hm:slurm:client::fromJsonValue(m_minimum_tmp_disk_per_node, json[QString("minimum_tmp_disk_per_node")]);
    m_minimum_tmp_disk_per_node_isSet = !json[QString("minimum_tmp_disk_per_node")].isNull() && m_minimum_tmp_disk_per_node_isValid;

    m_power_isValid = ::hm:slurm:client::fromJsonValue(m_power, json[QString("power")]);
    m_power_isSet = !json[QString("power")].isNull() && m_power_isValid;

    m_preempt_time_isValid = ::hm:slurm:client::fromJsonValue(m_preempt_time, json[QString("preempt_time")]);
    m_preempt_time_isSet = !json[QString("preempt_time")].isNull() && m_preempt_time_isValid;

    m_preemptable_time_isValid = ::hm:slurm:client::fromJsonValue(m_preemptable_time, json[QString("preemptable_time")]);
    m_preemptable_time_isSet = !json[QString("preemptable_time")].isNull() && m_preemptable_time_isValid;

    m_pre_sus_time_isValid = ::hm:slurm:client::fromJsonValue(m_pre_sus_time, json[QString("pre_sus_time")]);
    m_pre_sus_time_isSet = !json[QString("pre_sus_time")].isNull() && m_pre_sus_time_isValid;

    m_hold_isValid = ::hm:slurm:client::fromJsonValue(m_hold, json[QString("hold")]);
    m_hold_isSet = !json[QString("hold")].isNull() && m_hold_isValid;

    m_priority_isValid = ::hm:slurm:client::fromJsonValue(m_priority, json[QString("priority")]);
    m_priority_isSet = !json[QString("priority")].isNull() && m_priority_isValid;

    m_profile_isValid = ::hm:slurm:client::fromJsonValue(m_profile, json[QString("profile")]);
    m_profile_isSet = !json[QString("profile")].isNull() && m_profile_isValid;

    m_qos_isValid = ::hm:slurm:client::fromJsonValue(m_qos, json[QString("qos")]);
    m_qos_isSet = !json[QString("qos")].isNull() && m_qos_isValid;

    m_reboot_isValid = ::hm:slurm:client::fromJsonValue(m_reboot, json[QString("reboot")]);
    m_reboot_isSet = !json[QString("reboot")].isNull() && m_reboot_isValid;

    m_required_nodes_isValid = ::hm:slurm:client::fromJsonValue(m_required_nodes, json[QString("required_nodes")]);
    m_required_nodes_isSet = !json[QString("required_nodes")].isNull() && m_required_nodes_isValid;

    m_minimum_switches_isValid = ::hm:slurm:client::fromJsonValue(m_minimum_switches, json[QString("minimum_switches")]);
    m_minimum_switches_isSet = !json[QString("minimum_switches")].isNull() && m_minimum_switches_isValid;

    m_requeue_isValid = ::hm:slurm:client::fromJsonValue(m_requeue, json[QString("requeue")]);
    m_requeue_isSet = !json[QString("requeue")].isNull() && m_requeue_isValid;

    m_resize_time_isValid = ::hm:slurm:client::fromJsonValue(m_resize_time, json[QString("resize_time")]);
    m_resize_time_isSet = !json[QString("resize_time")].isNull() && m_resize_time_isValid;

    m_restart_cnt_isValid = ::hm:slurm:client::fromJsonValue(m_restart_cnt, json[QString("restart_cnt")]);
    m_restart_cnt_isSet = !json[QString("restart_cnt")].isNull() && m_restart_cnt_isValid;

    m_resv_name_isValid = ::hm:slurm:client::fromJsonValue(m_resv_name, json[QString("resv_name")]);
    m_resv_name_isSet = !json[QString("resv_name")].isNull() && m_resv_name_isValid;

    m_scheduled_nodes_isValid = ::hm:slurm:client::fromJsonValue(m_scheduled_nodes, json[QString("scheduled_nodes")]);
    m_scheduled_nodes_isSet = !json[QString("scheduled_nodes")].isNull() && m_scheduled_nodes_isValid;

    m_selinux_context_isValid = ::hm:slurm:client::fromJsonValue(m_selinux_context, json[QString("selinux_context")]);
    m_selinux_context_isSet = !json[QString("selinux_context")].isNull() && m_selinux_context_isValid;

    m_shared_isValid = ::hm:slurm:client::fromJsonValue(m_shared, json[QString("shared")]);
    m_shared_isSet = !json[QString("shared")].isNull() && m_shared_isValid;

    m_exclusive_isValid = ::hm:slurm:client::fromJsonValue(m_exclusive, json[QString("exclusive")]);
    m_exclusive_isSet = !json[QString("exclusive")].isNull() && m_exclusive_isValid;

    m_oversubscribe_isValid = ::hm:slurm:client::fromJsonValue(m_oversubscribe, json[QString("oversubscribe")]);
    m_oversubscribe_isSet = !json[QString("oversubscribe")].isNull() && m_oversubscribe_isValid;

    m_show_flags_isValid = ::hm:slurm:client::fromJsonValue(m_show_flags, json[QString("show_flags")]);
    m_show_flags_isSet = !json[QString("show_flags")].isNull() && m_show_flags_isValid;

    m_sockets_per_board_isValid = ::hm:slurm:client::fromJsonValue(m_sockets_per_board, json[QString("sockets_per_board")]);
    m_sockets_per_board_isSet = !json[QString("sockets_per_board")].isNull() && m_sockets_per_board_isValid;

    m_sockets_per_node_isValid = ::hm:slurm:client::fromJsonValue(m_sockets_per_node, json[QString("sockets_per_node")]);
    m_sockets_per_node_isSet = !json[QString("sockets_per_node")].isNull() && m_sockets_per_node_isValid;

    m_start_time_isValid = ::hm:slurm:client::fromJsonValue(m_start_time, json[QString("start_time")]);
    m_start_time_isSet = !json[QString("start_time")].isNull() && m_start_time_isValid;

    m_state_description_isValid = ::hm:slurm:client::fromJsonValue(m_state_description, json[QString("state_description")]);
    m_state_description_isSet = !json[QString("state_description")].isNull() && m_state_description_isValid;

    m_state_reason_isValid = ::hm:slurm:client::fromJsonValue(m_state_reason, json[QString("state_reason")]);
    m_state_reason_isSet = !json[QString("state_reason")].isNull() && m_state_reason_isValid;

    m_standard_error_isValid = ::hm:slurm:client::fromJsonValue(m_standard_error, json[QString("standard_error")]);
    m_standard_error_isSet = !json[QString("standard_error")].isNull() && m_standard_error_isValid;

    m_standard_input_isValid = ::hm:slurm:client::fromJsonValue(m_standard_input, json[QString("standard_input")]);
    m_standard_input_isSet = !json[QString("standard_input")].isNull() && m_standard_input_isValid;

    m_standard_output_isValid = ::hm:slurm:client::fromJsonValue(m_standard_output, json[QString("standard_output")]);
    m_standard_output_isSet = !json[QString("standard_output")].isNull() && m_standard_output_isValid;

    m_submit_time_isValid = ::hm:slurm:client::fromJsonValue(m_submit_time, json[QString("submit_time")]);
    m_submit_time_isSet = !json[QString("submit_time")].isNull() && m_submit_time_isValid;

    m_suspend_time_isValid = ::hm:slurm:client::fromJsonValue(m_suspend_time, json[QString("suspend_time")]);
    m_suspend_time_isSet = !json[QString("suspend_time")].isNull() && m_suspend_time_isValid;

    m_system_comment_isValid = ::hm:slurm:client::fromJsonValue(m_system_comment, json[QString("system_comment")]);
    m_system_comment_isSet = !json[QString("system_comment")].isNull() && m_system_comment_isValid;

    m_time_limit_isValid = ::hm:slurm:client::fromJsonValue(m_time_limit, json[QString("time_limit")]);
    m_time_limit_isSet = !json[QString("time_limit")].isNull() && m_time_limit_isValid;

    m_time_minimum_isValid = ::hm:slurm:client::fromJsonValue(m_time_minimum, json[QString("time_minimum")]);
    m_time_minimum_isSet = !json[QString("time_minimum")].isNull() && m_time_minimum_isValid;

    m_threads_per_core_isValid = ::hm:slurm:client::fromJsonValue(m_threads_per_core, json[QString("threads_per_core")]);
    m_threads_per_core_isSet = !json[QString("threads_per_core")].isNull() && m_threads_per_core_isValid;

    m_tres_bind_isValid = ::hm:slurm:client::fromJsonValue(m_tres_bind, json[QString("tres_bind")]);
    m_tres_bind_isSet = !json[QString("tres_bind")].isNull() && m_tres_bind_isValid;

    m_tres_freq_isValid = ::hm:slurm:client::fromJsonValue(m_tres_freq, json[QString("tres_freq")]);
    m_tres_freq_isSet = !json[QString("tres_freq")].isNull() && m_tres_freq_isValid;

    m_tres_per_job_isValid = ::hm:slurm:client::fromJsonValue(m_tres_per_job, json[QString("tres_per_job")]);
    m_tres_per_job_isSet = !json[QString("tres_per_job")].isNull() && m_tres_per_job_isValid;

    m_tres_per_node_isValid = ::hm:slurm:client::fromJsonValue(m_tres_per_node, json[QString("tres_per_node")]);
    m_tres_per_node_isSet = !json[QString("tres_per_node")].isNull() && m_tres_per_node_isValid;

    m_tres_per_socket_isValid = ::hm:slurm:client::fromJsonValue(m_tres_per_socket, json[QString("tres_per_socket")]);
    m_tres_per_socket_isSet = !json[QString("tres_per_socket")].isNull() && m_tres_per_socket_isValid;

    m_tres_per_task_isValid = ::hm:slurm:client::fromJsonValue(m_tres_per_task, json[QString("tres_per_task")]);
    m_tres_per_task_isSet = !json[QString("tres_per_task")].isNull() && m_tres_per_task_isValid;

    m_tres_req_str_isValid = ::hm:slurm:client::fromJsonValue(m_tres_req_str, json[QString("tres_req_str")]);
    m_tres_req_str_isSet = !json[QString("tres_req_str")].isNull() && m_tres_req_str_isValid;

    m_tres_alloc_str_isValid = ::hm:slurm:client::fromJsonValue(m_tres_alloc_str, json[QString("tres_alloc_str")]);
    m_tres_alloc_str_isSet = !json[QString("tres_alloc_str")].isNull() && m_tres_alloc_str_isValid;

    m_user_id_isValid = ::hm:slurm:client::fromJsonValue(m_user_id, json[QString("user_id")]);
    m_user_id_isSet = !json[QString("user_id")].isNull() && m_user_id_isValid;

    m_user_name_isValid = ::hm:slurm:client::fromJsonValue(m_user_name, json[QString("user_name")]);
    m_user_name_isSet = !json[QString("user_name")].isNull() && m_user_name_isValid;

    m_maximum_switch_wait_time_isValid = ::hm:slurm:client::fromJsonValue(m_maximum_switch_wait_time, json[QString("maximum_switch_wait_time")]);
    m_maximum_switch_wait_time_isSet = !json[QString("maximum_switch_wait_time")].isNull() && m_maximum_switch_wait_time_isValid;

    m_wckey_isValid = ::hm:slurm:client::fromJsonValue(m_wckey, json[QString("wckey")]);
    m_wckey_isSet = !json[QString("wckey")].isNull() && m_wckey_isValid;

    m_current_working_directory_isValid = ::hm:slurm:client::fromJsonValue(m_current_working_directory, json[QString("current_working_directory")]);
    m_current_working_directory_isSet = !json[QString("current_working_directory")].isNull() && m_current_working_directory_isValid;
}

QString OAIV0_0_39_job_info::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIV0_0_39_job_info::asJsonObject() const {
    QJsonObject obj;
    if (m_account_isSet) {
        obj.insert(QString("account"), ::hm:slurm:client::toJsonValue(m_account));
    }
    if (m_accrue_time_isSet) {
        obj.insert(QString("accrue_time"), ::hm:slurm:client::toJsonValue(m_accrue_time));
    }
    if (m_admin_comment_isSet) {
        obj.insert(QString("admin_comment"), ::hm:slurm:client::toJsonValue(m_admin_comment));
    }
    if (m_allocating_node_isSet) {
        obj.insert(QString("allocating_node"), ::hm:slurm:client::toJsonValue(m_allocating_node));
    }
    if (m_array_job_id.isSet()) {
        obj.insert(QString("array_job_id"), ::hm:slurm:client::toJsonValue(m_array_job_id));
    }
    if (m_array_task_id.isSet()) {
        obj.insert(QString("array_task_id"), ::hm:slurm:client::toJsonValue(m_array_task_id));
    }
    if (m_array_max_tasks.isSet()) {
        obj.insert(QString("array_max_tasks"), ::hm:slurm:client::toJsonValue(m_array_max_tasks));
    }
    if (m_array_task_string_isSet) {
        obj.insert(QString("array_task_string"), ::hm:slurm:client::toJsonValue(m_array_task_string));
    }
    if (m_association_id_isSet) {
        obj.insert(QString("association_id"), ::hm:slurm:client::toJsonValue(m_association_id));
    }
    if (m_batch_features_isSet) {
        obj.insert(QString("batch_features"), ::hm:slurm:client::toJsonValue(m_batch_features));
    }
    if (m_batch_flag_isSet) {
        obj.insert(QString("batch_flag"), ::hm:slurm:client::toJsonValue(m_batch_flag));
    }
    if (m_batch_host_isSet) {
        obj.insert(QString("batch_host"), ::hm:slurm:client::toJsonValue(m_batch_host));
    }
    if (m_flags.size() > 0) {
        obj.insert(QString("flags"), ::hm:slurm:client::toJsonValue(m_flags));
    }
    if (m_burst_buffer_isSet) {
        obj.insert(QString("burst_buffer"), ::hm:slurm:client::toJsonValue(m_burst_buffer));
    }
    if (m_burst_buffer_state_isSet) {
        obj.insert(QString("burst_buffer_state"), ::hm:slurm:client::toJsonValue(m_burst_buffer_state));
    }
    if (m_cluster_isSet) {
        obj.insert(QString("cluster"), ::hm:slurm:client::toJsonValue(m_cluster));
    }
    if (m_cluster_features_isSet) {
        obj.insert(QString("cluster_features"), ::hm:slurm:client::toJsonValue(m_cluster_features));
    }
    if (m_command_isSet) {
        obj.insert(QString("command"), ::hm:slurm:client::toJsonValue(m_command));
    }
    if (m_comment_isSet) {
        obj.insert(QString("comment"), ::hm:slurm:client::toJsonValue(m_comment));
    }
    if (m_container_isSet) {
        obj.insert(QString("container"), ::hm:slurm:client::toJsonValue(m_container));
    }
    if (m_container_id_isSet) {
        obj.insert(QString("container_id"), ::hm:slurm:client::toJsonValue(m_container_id));
    }
    if (m_contiguous_isSet) {
        obj.insert(QString("contiguous"), ::hm:slurm:client::toJsonValue(m_contiguous));
    }
    if (m_core_spec_isSet) {
        obj.insert(QString("core_spec"), ::hm:slurm:client::toJsonValue(m_core_spec));
    }
    if (m_thread_spec_isSet) {
        obj.insert(QString("thread_spec"), ::hm:slurm:client::toJsonValue(m_thread_spec));
    }
    if (m_cores_per_socket.isSet()) {
        obj.insert(QString("cores_per_socket"), ::hm:slurm:client::toJsonValue(m_cores_per_socket));
    }
    if (m_billable_tres.isSet()) {
        obj.insert(QString("billable_tres"), ::hm:slurm:client::toJsonValue(m_billable_tres));
    }
    if (m_cpus_per_task.isSet()) {
        obj.insert(QString("cpus_per_task"), ::hm:slurm:client::toJsonValue(m_cpus_per_task));
    }
    if (m_cpu_frequency_minimum.isSet()) {
        obj.insert(QString("cpu_frequency_minimum"), ::hm:slurm:client::toJsonValue(m_cpu_frequency_minimum));
    }
    if (m_cpu_frequency_maximum.isSet()) {
        obj.insert(QString("cpu_frequency_maximum"), ::hm:slurm:client::toJsonValue(m_cpu_frequency_maximum));
    }
    if (m_cpu_frequency_governor.isSet()) {
        obj.insert(QString("cpu_frequency_governor"), ::hm:slurm:client::toJsonValue(m_cpu_frequency_governor));
    }
    if (m_cpus_per_tres_isSet) {
        obj.insert(QString("cpus_per_tres"), ::hm:slurm:client::toJsonValue(m_cpus_per_tres));
    }
    if (m_cron_isSet) {
        obj.insert(QString("cron"), ::hm:slurm:client::toJsonValue(m_cron));
    }
    if (m_deadline_isSet) {
        obj.insert(QString("deadline"), ::hm:slurm:client::toJsonValue(m_deadline));
    }
    if (m_delay_boot.isSet()) {
        obj.insert(QString("delay_boot"), ::hm:slurm:client::toJsonValue(m_delay_boot));
    }
    if (m_dependency_isSet) {
        obj.insert(QString("dependency"), ::hm:slurm:client::toJsonValue(m_dependency));
    }
    if (m_derived_exit_code.isSet()) {
        obj.insert(QString("derived_exit_code"), ::hm:slurm:client::toJsonValue(m_derived_exit_code));
    }
    if (m_eligible_time_isSet) {
        obj.insert(QString("eligible_time"), ::hm:slurm:client::toJsonValue(m_eligible_time));
    }
    if (m_end_time_isSet) {
        obj.insert(QString("end_time"), ::hm:slurm:client::toJsonValue(m_end_time));
    }
    if (m_excluded_nodes_isSet) {
        obj.insert(QString("excluded_nodes"), ::hm:slurm:client::toJsonValue(m_excluded_nodes));
    }
    if (m_exit_code.isSet()) {
        obj.insert(QString("exit_code"), ::hm:slurm:client::toJsonValue(m_exit_code));
    }
    if (m_extra_isSet) {
        obj.insert(QString("extra"), ::hm:slurm:client::toJsonValue(m_extra));
    }
    if (m_failed_node_isSet) {
        obj.insert(QString("failed_node"), ::hm:slurm:client::toJsonValue(m_failed_node));
    }
    if (m_features_isSet) {
        obj.insert(QString("features"), ::hm:slurm:client::toJsonValue(m_features));
    }
    if (m_federation_origin_isSet) {
        obj.insert(QString("federation_origin"), ::hm:slurm:client::toJsonValue(m_federation_origin));
    }
    if (m_federation_siblings_active_isSet) {
        obj.insert(QString("federation_siblings_active"), ::hm:slurm:client::toJsonValue(m_federation_siblings_active));
    }
    if (m_federation_siblings_viable_isSet) {
        obj.insert(QString("federation_siblings_viable"), ::hm:slurm:client::toJsonValue(m_federation_siblings_viable));
    }
    if (m_gres_detail.size() > 0) {
        obj.insert(QString("gres_detail"), ::hm:slurm:client::toJsonValue(m_gres_detail));
    }
    if (m_group_id_isSet) {
        obj.insert(QString("group_id"), ::hm:slurm:client::toJsonValue(m_group_id));
    }
    if (m_group_name_isSet) {
        obj.insert(QString("group_name"), ::hm:slurm:client::toJsonValue(m_group_name));
    }
    if (m_het_job_id.isSet()) {
        obj.insert(QString("het_job_id"), ::hm:slurm:client::toJsonValue(m_het_job_id));
    }
    if (m_het_job_id_set_isSet) {
        obj.insert(QString("het_job_id_set"), ::hm:slurm:client::toJsonValue(m_het_job_id_set));
    }
    if (m_het_job_offset.isSet()) {
        obj.insert(QString("het_job_offset"), ::hm:slurm:client::toJsonValue(m_het_job_offset));
    }
    if (m_job_id_isSet) {
        obj.insert(QString("job_id"), ::hm:slurm:client::toJsonValue(m_job_id));
    }
    if (m_job_resources.isSet()) {
        obj.insert(QString("job_resources"), ::hm:slurm:client::toJsonValue(m_job_resources));
    }
    if (m_job_size_str.size() > 0) {
        obj.insert(QString("job_size_str"), ::hm:slurm:client::toJsonValue(m_job_size_str));
    }
    if (m_job_state_isSet) {
        obj.insert(QString("job_state"), ::hm:slurm:client::toJsonValue(m_job_state));
    }
    if (m_last_sched_evaluation_isSet) {
        obj.insert(QString("last_sched_evaluation"), ::hm:slurm:client::toJsonValue(m_last_sched_evaluation));
    }
    if (m_licenses_isSet) {
        obj.insert(QString("licenses"), ::hm:slurm:client::toJsonValue(m_licenses));
    }
    if (m_mail_type.size() > 0) {
        obj.insert(QString("mail_type"), ::hm:slurm:client::toJsonValue(m_mail_type));
    }
    if (m_mail_user_isSet) {
        obj.insert(QString("mail_user"), ::hm:slurm:client::toJsonValue(m_mail_user));
    }
    if (m_max_cpus.isSet()) {
        obj.insert(QString("max_cpus"), ::hm:slurm:client::toJsonValue(m_max_cpus));
    }
    if (m_max_nodes.isSet()) {
        obj.insert(QString("max_nodes"), ::hm:slurm:client::toJsonValue(m_max_nodes));
    }
    if (m_mcs_label_isSet) {
        obj.insert(QString("mcs_label"), ::hm:slurm:client::toJsonValue(m_mcs_label));
    }
    if (m_memory_per_tres_isSet) {
        obj.insert(QString("memory_per_tres"), ::hm:slurm:client::toJsonValue(m_memory_per_tres));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::hm:slurm:client::toJsonValue(m_name));
    }
    if (m_network_isSet) {
        obj.insert(QString("network"), ::hm:slurm:client::toJsonValue(m_network));
    }
    if (m_nodes_isSet) {
        obj.insert(QString("nodes"), ::hm:slurm:client::toJsonValue(m_nodes));
    }
    if (m_nice_isSet) {
        obj.insert(QString("nice"), ::hm:slurm:client::toJsonValue(m_nice));
    }
    if (m_tasks_per_core.isSet()) {
        obj.insert(QString("tasks_per_core"), ::hm:slurm:client::toJsonValue(m_tasks_per_core));
    }
    if (m_tasks_per_tres.isSet()) {
        obj.insert(QString("tasks_per_tres"), ::hm:slurm:client::toJsonValue(m_tasks_per_tres));
    }
    if (m_tasks_per_node.isSet()) {
        obj.insert(QString("tasks_per_node"), ::hm:slurm:client::toJsonValue(m_tasks_per_node));
    }
    if (m_tasks_per_socket.isSet()) {
        obj.insert(QString("tasks_per_socket"), ::hm:slurm:client::toJsonValue(m_tasks_per_socket));
    }
    if (m_tasks_per_board.isSet()) {
        obj.insert(QString("tasks_per_board"), ::hm:slurm:client::toJsonValue(m_tasks_per_board));
    }
    if (m_cpus.isSet()) {
        obj.insert(QString("cpus"), ::hm:slurm:client::toJsonValue(m_cpus));
    }
    if (m_node_count.isSet()) {
        obj.insert(QString("node_count"), ::hm:slurm:client::toJsonValue(m_node_count));
    }
    if (m_tasks.isSet()) {
        obj.insert(QString("tasks"), ::hm:slurm:client::toJsonValue(m_tasks));
    }
    if (m_partition_isSet) {
        obj.insert(QString("partition"), ::hm:slurm:client::toJsonValue(m_partition));
    }
    if (m_prefer_isSet) {
        obj.insert(QString("prefer"), ::hm:slurm:client::toJsonValue(m_prefer));
    }
    if (m_memory_per_cpu.isSet()) {
        obj.insert(QString("memory_per_cpu"), ::hm:slurm:client::toJsonValue(m_memory_per_cpu));
    }
    if (m_memory_per_node.isSet()) {
        obj.insert(QString("memory_per_node"), ::hm:slurm:client::toJsonValue(m_memory_per_node));
    }
    if (m_minimum_cpus_per_node.isSet()) {
        obj.insert(QString("minimum_cpus_per_node"), ::hm:slurm:client::toJsonValue(m_minimum_cpus_per_node));
    }
    if (m_minimum_tmp_disk_per_node.isSet()) {
        obj.insert(QString("minimum_tmp_disk_per_node"), ::hm:slurm:client::toJsonValue(m_minimum_tmp_disk_per_node));
    }
    if (m_power.isSet()) {
        obj.insert(QString("power"), ::hm:slurm:client::toJsonValue(m_power));
    }
    if (m_preempt_time_isSet) {
        obj.insert(QString("preempt_time"), ::hm:slurm:client::toJsonValue(m_preempt_time));
    }
    if (m_preemptable_time_isSet) {
        obj.insert(QString("preemptable_time"), ::hm:slurm:client::toJsonValue(m_preemptable_time));
    }
    if (m_pre_sus_time_isSet) {
        obj.insert(QString("pre_sus_time"), ::hm:slurm:client::toJsonValue(m_pre_sus_time));
    }
    if (m_hold_isSet) {
        obj.insert(QString("hold"), ::hm:slurm:client::toJsonValue(m_hold));
    }
    if (m_priority.isSet()) {
        obj.insert(QString("priority"), ::hm:slurm:client::toJsonValue(m_priority));
    }
    if (m_profile.size() > 0) {
        obj.insert(QString("profile"), ::hm:slurm:client::toJsonValue(m_profile));
    }
    if (m_qos_isSet) {
        obj.insert(QString("qos"), ::hm:slurm:client::toJsonValue(m_qos));
    }
    if (m_reboot_isSet) {
        obj.insert(QString("reboot"), ::hm:slurm:client::toJsonValue(m_reboot));
    }
    if (m_required_nodes_isSet) {
        obj.insert(QString("required_nodes"), ::hm:slurm:client::toJsonValue(m_required_nodes));
    }
    if (m_minimum_switches_isSet) {
        obj.insert(QString("minimum_switches"), ::hm:slurm:client::toJsonValue(m_minimum_switches));
    }
    if (m_requeue_isSet) {
        obj.insert(QString("requeue"), ::hm:slurm:client::toJsonValue(m_requeue));
    }
    if (m_resize_time_isSet) {
        obj.insert(QString("resize_time"), ::hm:slurm:client::toJsonValue(m_resize_time));
    }
    if (m_restart_cnt_isSet) {
        obj.insert(QString("restart_cnt"), ::hm:slurm:client::toJsonValue(m_restart_cnt));
    }
    if (m_resv_name_isSet) {
        obj.insert(QString("resv_name"), ::hm:slurm:client::toJsonValue(m_resv_name));
    }
    if (m_scheduled_nodes_isSet) {
        obj.insert(QString("scheduled_nodes"), ::hm:slurm:client::toJsonValue(m_scheduled_nodes));
    }
    if (m_selinux_context_isSet) {
        obj.insert(QString("selinux_context"), ::hm:slurm:client::toJsonValue(m_selinux_context));
    }
    if (m_shared.size() > 0) {
        obj.insert(QString("shared"), ::hm:slurm:client::toJsonValue(m_shared));
    }
    if (m_exclusive.size() > 0) {
        obj.insert(QString("exclusive"), ::hm:slurm:client::toJsonValue(m_exclusive));
    }
    if (m_oversubscribe_isSet) {
        obj.insert(QString("oversubscribe"), ::hm:slurm:client::toJsonValue(m_oversubscribe));
    }
    if (m_show_flags.size() > 0) {
        obj.insert(QString("show_flags"), ::hm:slurm:client::toJsonValue(m_show_flags));
    }
    if (m_sockets_per_board_isSet) {
        obj.insert(QString("sockets_per_board"), ::hm:slurm:client::toJsonValue(m_sockets_per_board));
    }
    if (m_sockets_per_node.isSet()) {
        obj.insert(QString("sockets_per_node"), ::hm:slurm:client::toJsonValue(m_sockets_per_node));
    }
    if (m_start_time_isSet) {
        obj.insert(QString("start_time"), ::hm:slurm:client::toJsonValue(m_start_time));
    }
    if (m_state_description_isSet) {
        obj.insert(QString("state_description"), ::hm:slurm:client::toJsonValue(m_state_description));
    }
    if (m_state_reason_isSet) {
        obj.insert(QString("state_reason"), ::hm:slurm:client::toJsonValue(m_state_reason));
    }
    if (m_standard_error_isSet) {
        obj.insert(QString("standard_error"), ::hm:slurm:client::toJsonValue(m_standard_error));
    }
    if (m_standard_input_isSet) {
        obj.insert(QString("standard_input"), ::hm:slurm:client::toJsonValue(m_standard_input));
    }
    if (m_standard_output_isSet) {
        obj.insert(QString("standard_output"), ::hm:slurm:client::toJsonValue(m_standard_output));
    }
    if (m_submit_time_isSet) {
        obj.insert(QString("submit_time"), ::hm:slurm:client::toJsonValue(m_submit_time));
    }
    if (m_suspend_time_isSet) {
        obj.insert(QString("suspend_time"), ::hm:slurm:client::toJsonValue(m_suspend_time));
    }
    if (m_system_comment_isSet) {
        obj.insert(QString("system_comment"), ::hm:slurm:client::toJsonValue(m_system_comment));
    }
    if (m_time_limit.isSet()) {
        obj.insert(QString("time_limit"), ::hm:slurm:client::toJsonValue(m_time_limit));
    }
    if (m_time_minimum.isSet()) {
        obj.insert(QString("time_minimum"), ::hm:slurm:client::toJsonValue(m_time_minimum));
    }
    if (m_threads_per_core.isSet()) {
        obj.insert(QString("threads_per_core"), ::hm:slurm:client::toJsonValue(m_threads_per_core));
    }
    if (m_tres_bind_isSet) {
        obj.insert(QString("tres_bind"), ::hm:slurm:client::toJsonValue(m_tres_bind));
    }
    if (m_tres_freq_isSet) {
        obj.insert(QString("tres_freq"), ::hm:slurm:client::toJsonValue(m_tres_freq));
    }
    if (m_tres_per_job_isSet) {
        obj.insert(QString("tres_per_job"), ::hm:slurm:client::toJsonValue(m_tres_per_job));
    }
    if (m_tres_per_node_isSet) {
        obj.insert(QString("tres_per_node"), ::hm:slurm:client::toJsonValue(m_tres_per_node));
    }
    if (m_tres_per_socket_isSet) {
        obj.insert(QString("tres_per_socket"), ::hm:slurm:client::toJsonValue(m_tres_per_socket));
    }
    if (m_tres_per_task_isSet) {
        obj.insert(QString("tres_per_task"), ::hm:slurm:client::toJsonValue(m_tres_per_task));
    }
    if (m_tres_req_str_isSet) {
        obj.insert(QString("tres_req_str"), ::hm:slurm:client::toJsonValue(m_tres_req_str));
    }
    if (m_tres_alloc_str_isSet) {
        obj.insert(QString("tres_alloc_str"), ::hm:slurm:client::toJsonValue(m_tres_alloc_str));
    }
    if (m_user_id_isSet) {
        obj.insert(QString("user_id"), ::hm:slurm:client::toJsonValue(m_user_id));
    }
    if (m_user_name_isSet) {
        obj.insert(QString("user_name"), ::hm:slurm:client::toJsonValue(m_user_name));
    }
    if (m_maximum_switch_wait_time_isSet) {
        obj.insert(QString("maximum_switch_wait_time"), ::hm:slurm:client::toJsonValue(m_maximum_switch_wait_time));
    }
    if (m_wckey_isSet) {
        obj.insert(QString("wckey"), ::hm:slurm:client::toJsonValue(m_wckey));
    }
    if (m_current_working_directory_isSet) {
        obj.insert(QString("current_working_directory"), ::hm:slurm:client::toJsonValue(m_current_working_directory));
    }
    return obj;
}

QString OAIV0_0_39_job_info::getAccount() const {
    return m_account;
}
void OAIV0_0_39_job_info::setAccount(const QString &account) {
    m_account = account;
    m_account_isSet = true;
}

bool OAIV0_0_39_job_info::is_account_Set() const{
    return m_account_isSet;
}

bool OAIV0_0_39_job_info::is_account_Valid() const{
    return m_account_isValid;
}

qint64 OAIV0_0_39_job_info::getAccrueTime() const {
    return m_accrue_time;
}
void OAIV0_0_39_job_info::setAccrueTime(const qint64 &accrue_time) {
    m_accrue_time = accrue_time;
    m_accrue_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_accrue_time_Set() const{
    return m_accrue_time_isSet;
}

bool OAIV0_0_39_job_info::is_accrue_time_Valid() const{
    return m_accrue_time_isValid;
}

QString OAIV0_0_39_job_info::getAdminComment() const {
    return m_admin_comment;
}
void OAIV0_0_39_job_info::setAdminComment(const QString &admin_comment) {
    m_admin_comment = admin_comment;
    m_admin_comment_isSet = true;
}

bool OAIV0_0_39_job_info::is_admin_comment_Set() const{
    return m_admin_comment_isSet;
}

bool OAIV0_0_39_job_info::is_admin_comment_Valid() const{
    return m_admin_comment_isValid;
}

QString OAIV0_0_39_job_info::getAllocatingNode() const {
    return m_allocating_node;
}
void OAIV0_0_39_job_info::setAllocatingNode(const QString &allocating_node) {
    m_allocating_node = allocating_node;
    m_allocating_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_allocating_node_Set() const{
    return m_allocating_node_isSet;
}

bool OAIV0_0_39_job_info::is_allocating_node_Valid() const{
    return m_allocating_node_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getArrayJobId() const {
    return m_array_job_id;
}
void OAIV0_0_39_job_info::setArrayJobId(const OAIV0_0_39_uint32_no_val &array_job_id) {
    m_array_job_id = array_job_id;
    m_array_job_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_array_job_id_Set() const{
    return m_array_job_id_isSet;
}

bool OAIV0_0_39_job_info::is_array_job_id_Valid() const{
    return m_array_job_id_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getArrayTaskId() const {
    return m_array_task_id;
}
void OAIV0_0_39_job_info::setArrayTaskId(const OAIV0_0_39_uint32_no_val &array_task_id) {
    m_array_task_id = array_task_id;
    m_array_task_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_array_task_id_Set() const{
    return m_array_task_id_isSet;
}

bool OAIV0_0_39_job_info::is_array_task_id_Valid() const{
    return m_array_task_id_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getArrayMaxTasks() const {
    return m_array_max_tasks;
}
void OAIV0_0_39_job_info::setArrayMaxTasks(const OAIV0_0_39_uint32_no_val &array_max_tasks) {
    m_array_max_tasks = array_max_tasks;
    m_array_max_tasks_isSet = true;
}

bool OAIV0_0_39_job_info::is_array_max_tasks_Set() const{
    return m_array_max_tasks_isSet;
}

bool OAIV0_0_39_job_info::is_array_max_tasks_Valid() const{
    return m_array_max_tasks_isValid;
}

QString OAIV0_0_39_job_info::getArrayTaskString() const {
    return m_array_task_string;
}
void OAIV0_0_39_job_info::setArrayTaskString(const QString &array_task_string) {
    m_array_task_string = array_task_string;
    m_array_task_string_isSet = true;
}

bool OAIV0_0_39_job_info::is_array_task_string_Set() const{
    return m_array_task_string_isSet;
}

bool OAIV0_0_39_job_info::is_array_task_string_Valid() const{
    return m_array_task_string_isValid;
}

qint32 OAIV0_0_39_job_info::getAssociationId() const {
    return m_association_id;
}
void OAIV0_0_39_job_info::setAssociationId(const qint32 &association_id) {
    m_association_id = association_id;
    m_association_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_association_id_Set() const{
    return m_association_id_isSet;
}

bool OAIV0_0_39_job_info::is_association_id_Valid() const{
    return m_association_id_isValid;
}

QString OAIV0_0_39_job_info::getBatchFeatures() const {
    return m_batch_features;
}
void OAIV0_0_39_job_info::setBatchFeatures(const QString &batch_features) {
    m_batch_features = batch_features;
    m_batch_features_isSet = true;
}

bool OAIV0_0_39_job_info::is_batch_features_Set() const{
    return m_batch_features_isSet;
}

bool OAIV0_0_39_job_info::is_batch_features_Valid() const{
    return m_batch_features_isValid;
}

bool OAIV0_0_39_job_info::isBatchFlag() const {
    return m_batch_flag;
}
void OAIV0_0_39_job_info::setBatchFlag(const bool &batch_flag) {
    m_batch_flag = batch_flag;
    m_batch_flag_isSet = true;
}

bool OAIV0_0_39_job_info::is_batch_flag_Set() const{
    return m_batch_flag_isSet;
}

bool OAIV0_0_39_job_info::is_batch_flag_Valid() const{
    return m_batch_flag_isValid;
}

QString OAIV0_0_39_job_info::getBatchHost() const {
    return m_batch_host;
}
void OAIV0_0_39_job_info::setBatchHost(const QString &batch_host) {
    m_batch_host = batch_host;
    m_batch_host_isSet = true;
}

bool OAIV0_0_39_job_info::is_batch_host_Set() const{
    return m_batch_host_isSet;
}

bool OAIV0_0_39_job_info::is_batch_host_Valid() const{
    return m_batch_host_isValid;
}

QList<QString> OAIV0_0_39_job_info::getFlags() const {
    return m_flags;
}
void OAIV0_0_39_job_info::setFlags(const QList<QString> &flags) {
    m_flags = flags;
    m_flags_isSet = true;
}

bool OAIV0_0_39_job_info::is_flags_Set() const{
    return m_flags_isSet;
}

bool OAIV0_0_39_job_info::is_flags_Valid() const{
    return m_flags_isValid;
}

QString OAIV0_0_39_job_info::getBurstBuffer() const {
    return m_burst_buffer;
}
void OAIV0_0_39_job_info::setBurstBuffer(const QString &burst_buffer) {
    m_burst_buffer = burst_buffer;
    m_burst_buffer_isSet = true;
}

bool OAIV0_0_39_job_info::is_burst_buffer_Set() const{
    return m_burst_buffer_isSet;
}

bool OAIV0_0_39_job_info::is_burst_buffer_Valid() const{
    return m_burst_buffer_isValid;
}

QString OAIV0_0_39_job_info::getBurstBufferState() const {
    return m_burst_buffer_state;
}
void OAIV0_0_39_job_info::setBurstBufferState(const QString &burst_buffer_state) {
    m_burst_buffer_state = burst_buffer_state;
    m_burst_buffer_state_isSet = true;
}

bool OAIV0_0_39_job_info::is_burst_buffer_state_Set() const{
    return m_burst_buffer_state_isSet;
}

bool OAIV0_0_39_job_info::is_burst_buffer_state_Valid() const{
    return m_burst_buffer_state_isValid;
}

QString OAIV0_0_39_job_info::getCluster() const {
    return m_cluster;
}
void OAIV0_0_39_job_info::setCluster(const QString &cluster) {
    m_cluster = cluster;
    m_cluster_isSet = true;
}

bool OAIV0_0_39_job_info::is_cluster_Set() const{
    return m_cluster_isSet;
}

bool OAIV0_0_39_job_info::is_cluster_Valid() const{
    return m_cluster_isValid;
}

QString OAIV0_0_39_job_info::getClusterFeatures() const {
    return m_cluster_features;
}
void OAIV0_0_39_job_info::setClusterFeatures(const QString &cluster_features) {
    m_cluster_features = cluster_features;
    m_cluster_features_isSet = true;
}

bool OAIV0_0_39_job_info::is_cluster_features_Set() const{
    return m_cluster_features_isSet;
}

bool OAIV0_0_39_job_info::is_cluster_features_Valid() const{
    return m_cluster_features_isValid;
}

QString OAIV0_0_39_job_info::getCommand() const {
    return m_command;
}
void OAIV0_0_39_job_info::setCommand(const QString &command) {
    m_command = command;
    m_command_isSet = true;
}

bool OAIV0_0_39_job_info::is_command_Set() const{
    return m_command_isSet;
}

bool OAIV0_0_39_job_info::is_command_Valid() const{
    return m_command_isValid;
}

QString OAIV0_0_39_job_info::getComment() const {
    return m_comment;
}
void OAIV0_0_39_job_info::setComment(const QString &comment) {
    m_comment = comment;
    m_comment_isSet = true;
}

bool OAIV0_0_39_job_info::is_comment_Set() const{
    return m_comment_isSet;
}

bool OAIV0_0_39_job_info::is_comment_Valid() const{
    return m_comment_isValid;
}

QString OAIV0_0_39_job_info::getContainer() const {
    return m_container;
}
void OAIV0_0_39_job_info::setContainer(const QString &container) {
    m_container = container;
    m_container_isSet = true;
}

bool OAIV0_0_39_job_info::is_container_Set() const{
    return m_container_isSet;
}

bool OAIV0_0_39_job_info::is_container_Valid() const{
    return m_container_isValid;
}

QString OAIV0_0_39_job_info::getContainerId() const {
    return m_container_id;
}
void OAIV0_0_39_job_info::setContainerId(const QString &container_id) {
    m_container_id = container_id;
    m_container_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_container_id_Set() const{
    return m_container_id_isSet;
}

bool OAIV0_0_39_job_info::is_container_id_Valid() const{
    return m_container_id_isValid;
}

bool OAIV0_0_39_job_info::isContiguous() const {
    return m_contiguous;
}
void OAIV0_0_39_job_info::setContiguous(const bool &contiguous) {
    m_contiguous = contiguous;
    m_contiguous_isSet = true;
}

bool OAIV0_0_39_job_info::is_contiguous_Set() const{
    return m_contiguous_isSet;
}

bool OAIV0_0_39_job_info::is_contiguous_Valid() const{
    return m_contiguous_isValid;
}

qint32 OAIV0_0_39_job_info::getCoreSpec() const {
    return m_core_spec;
}
void OAIV0_0_39_job_info::setCoreSpec(const qint32 &core_spec) {
    m_core_spec = core_spec;
    m_core_spec_isSet = true;
}

bool OAIV0_0_39_job_info::is_core_spec_Set() const{
    return m_core_spec_isSet;
}

bool OAIV0_0_39_job_info::is_core_spec_Valid() const{
    return m_core_spec_isValid;
}

qint32 OAIV0_0_39_job_info::getThreadSpec() const {
    return m_thread_spec;
}
void OAIV0_0_39_job_info::setThreadSpec(const qint32 &thread_spec) {
    m_thread_spec = thread_spec;
    m_thread_spec_isSet = true;
}

bool OAIV0_0_39_job_info::is_thread_spec_Set() const{
    return m_thread_spec_isSet;
}

bool OAIV0_0_39_job_info::is_thread_spec_Valid() const{
    return m_thread_spec_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getCoresPerSocket() const {
    return m_cores_per_socket;
}
void OAIV0_0_39_job_info::setCoresPerSocket(const OAIV0_0_39_uint16_no_val &cores_per_socket) {
    m_cores_per_socket = cores_per_socket;
    m_cores_per_socket_isSet = true;
}

bool OAIV0_0_39_job_info::is_cores_per_socket_Set() const{
    return m_cores_per_socket_isSet;
}

bool OAIV0_0_39_job_info::is_cores_per_socket_Valid() const{
    return m_cores_per_socket_isValid;
}

OAIV0_0_39_float64_no_val OAIV0_0_39_job_info::getBillableTres() const {
    return m_billable_tres;
}
void OAIV0_0_39_job_info::setBillableTres(const OAIV0_0_39_float64_no_val &billable_tres) {
    m_billable_tres = billable_tres;
    m_billable_tres_isSet = true;
}

bool OAIV0_0_39_job_info::is_billable_tres_Set() const{
    return m_billable_tres_isSet;
}

bool OAIV0_0_39_job_info::is_billable_tres_Valid() const{
    return m_billable_tres_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getCpusPerTask() const {
    return m_cpus_per_task;
}
void OAIV0_0_39_job_info::setCpusPerTask(const OAIV0_0_39_uint16_no_val &cpus_per_task) {
    m_cpus_per_task = cpus_per_task;
    m_cpus_per_task_isSet = true;
}

bool OAIV0_0_39_job_info::is_cpus_per_task_Set() const{
    return m_cpus_per_task_isSet;
}

bool OAIV0_0_39_job_info::is_cpus_per_task_Valid() const{
    return m_cpus_per_task_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getCpuFrequencyMinimum() const {
    return m_cpu_frequency_minimum;
}
void OAIV0_0_39_job_info::setCpuFrequencyMinimum(const OAIV0_0_39_uint32_no_val &cpu_frequency_minimum) {
    m_cpu_frequency_minimum = cpu_frequency_minimum;
    m_cpu_frequency_minimum_isSet = true;
}

bool OAIV0_0_39_job_info::is_cpu_frequency_minimum_Set() const{
    return m_cpu_frequency_minimum_isSet;
}

bool OAIV0_0_39_job_info::is_cpu_frequency_minimum_Valid() const{
    return m_cpu_frequency_minimum_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getCpuFrequencyMaximum() const {
    return m_cpu_frequency_maximum;
}
void OAIV0_0_39_job_info::setCpuFrequencyMaximum(const OAIV0_0_39_uint32_no_val &cpu_frequency_maximum) {
    m_cpu_frequency_maximum = cpu_frequency_maximum;
    m_cpu_frequency_maximum_isSet = true;
}

bool OAIV0_0_39_job_info::is_cpu_frequency_maximum_Set() const{
    return m_cpu_frequency_maximum_isSet;
}

bool OAIV0_0_39_job_info::is_cpu_frequency_maximum_Valid() const{
    return m_cpu_frequency_maximum_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getCpuFrequencyGovernor() const {
    return m_cpu_frequency_governor;
}
void OAIV0_0_39_job_info::setCpuFrequencyGovernor(const OAIV0_0_39_uint32_no_val &cpu_frequency_governor) {
    m_cpu_frequency_governor = cpu_frequency_governor;
    m_cpu_frequency_governor_isSet = true;
}

bool OAIV0_0_39_job_info::is_cpu_frequency_governor_Set() const{
    return m_cpu_frequency_governor_isSet;
}

bool OAIV0_0_39_job_info::is_cpu_frequency_governor_Valid() const{
    return m_cpu_frequency_governor_isValid;
}

QString OAIV0_0_39_job_info::getCpusPerTres() const {
    return m_cpus_per_tres;
}
void OAIV0_0_39_job_info::setCpusPerTres(const QString &cpus_per_tres) {
    m_cpus_per_tres = cpus_per_tres;
    m_cpus_per_tres_isSet = true;
}

bool OAIV0_0_39_job_info::is_cpus_per_tres_Set() const{
    return m_cpus_per_tres_isSet;
}

bool OAIV0_0_39_job_info::is_cpus_per_tres_Valid() const{
    return m_cpus_per_tres_isValid;
}

QString OAIV0_0_39_job_info::getCron() const {
    return m_cron;
}
void OAIV0_0_39_job_info::setCron(const QString &cron) {
    m_cron = cron;
    m_cron_isSet = true;
}

bool OAIV0_0_39_job_info::is_cron_Set() const{
    return m_cron_isSet;
}

bool OAIV0_0_39_job_info::is_cron_Valid() const{
    return m_cron_isValid;
}

qint64 OAIV0_0_39_job_info::getDeadline() const {
    return m_deadline;
}
void OAIV0_0_39_job_info::setDeadline(const qint64 &deadline) {
    m_deadline = deadline;
    m_deadline_isSet = true;
}

bool OAIV0_0_39_job_info::is_deadline_Set() const{
    return m_deadline_isSet;
}

bool OAIV0_0_39_job_info::is_deadline_Valid() const{
    return m_deadline_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getDelayBoot() const {
    return m_delay_boot;
}
void OAIV0_0_39_job_info::setDelayBoot(const OAIV0_0_39_uint32_no_val &delay_boot) {
    m_delay_boot = delay_boot;
    m_delay_boot_isSet = true;
}

bool OAIV0_0_39_job_info::is_delay_boot_Set() const{
    return m_delay_boot_isSet;
}

bool OAIV0_0_39_job_info::is_delay_boot_Valid() const{
    return m_delay_boot_isValid;
}

QString OAIV0_0_39_job_info::getDependency() const {
    return m_dependency;
}
void OAIV0_0_39_job_info::setDependency(const QString &dependency) {
    m_dependency = dependency;
    m_dependency_isSet = true;
}

bool OAIV0_0_39_job_info::is_dependency_Set() const{
    return m_dependency_isSet;
}

bool OAIV0_0_39_job_info::is_dependency_Valid() const{
    return m_dependency_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getDerivedExitCode() const {
    return m_derived_exit_code;
}
void OAIV0_0_39_job_info::setDerivedExitCode(const OAIV0_0_39_uint32_no_val &derived_exit_code) {
    m_derived_exit_code = derived_exit_code;
    m_derived_exit_code_isSet = true;
}

bool OAIV0_0_39_job_info::is_derived_exit_code_Set() const{
    return m_derived_exit_code_isSet;
}

bool OAIV0_0_39_job_info::is_derived_exit_code_Valid() const{
    return m_derived_exit_code_isValid;
}

qint64 OAIV0_0_39_job_info::getEligibleTime() const {
    return m_eligible_time;
}
void OAIV0_0_39_job_info::setEligibleTime(const qint64 &eligible_time) {
    m_eligible_time = eligible_time;
    m_eligible_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_eligible_time_Set() const{
    return m_eligible_time_isSet;
}

bool OAIV0_0_39_job_info::is_eligible_time_Valid() const{
    return m_eligible_time_isValid;
}

qint64 OAIV0_0_39_job_info::getEndTime() const {
    return m_end_time;
}
void OAIV0_0_39_job_info::setEndTime(const qint64 &end_time) {
    m_end_time = end_time;
    m_end_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_end_time_Set() const{
    return m_end_time_isSet;
}

bool OAIV0_0_39_job_info::is_end_time_Valid() const{
    return m_end_time_isValid;
}

QString OAIV0_0_39_job_info::getExcludedNodes() const {
    return m_excluded_nodes;
}
void OAIV0_0_39_job_info::setExcludedNodes(const QString &excluded_nodes) {
    m_excluded_nodes = excluded_nodes;
    m_excluded_nodes_isSet = true;
}

bool OAIV0_0_39_job_info::is_excluded_nodes_Set() const{
    return m_excluded_nodes_isSet;
}

bool OAIV0_0_39_job_info::is_excluded_nodes_Valid() const{
    return m_excluded_nodes_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getExitCode() const {
    return m_exit_code;
}
void OAIV0_0_39_job_info::setExitCode(const OAIV0_0_39_uint32_no_val &exit_code) {
    m_exit_code = exit_code;
    m_exit_code_isSet = true;
}

bool OAIV0_0_39_job_info::is_exit_code_Set() const{
    return m_exit_code_isSet;
}

bool OAIV0_0_39_job_info::is_exit_code_Valid() const{
    return m_exit_code_isValid;
}

QString OAIV0_0_39_job_info::getExtra() const {
    return m_extra;
}
void OAIV0_0_39_job_info::setExtra(const QString &extra) {
    m_extra = extra;
    m_extra_isSet = true;
}

bool OAIV0_0_39_job_info::is_extra_Set() const{
    return m_extra_isSet;
}

bool OAIV0_0_39_job_info::is_extra_Valid() const{
    return m_extra_isValid;
}

QString OAIV0_0_39_job_info::getFailedNode() const {
    return m_failed_node;
}
void OAIV0_0_39_job_info::setFailedNode(const QString &failed_node) {
    m_failed_node = failed_node;
    m_failed_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_failed_node_Set() const{
    return m_failed_node_isSet;
}

bool OAIV0_0_39_job_info::is_failed_node_Valid() const{
    return m_failed_node_isValid;
}

QString OAIV0_0_39_job_info::getFeatures() const {
    return m_features;
}
void OAIV0_0_39_job_info::setFeatures(const QString &features) {
    m_features = features;
    m_features_isSet = true;
}

bool OAIV0_0_39_job_info::is_features_Set() const{
    return m_features_isSet;
}

bool OAIV0_0_39_job_info::is_features_Valid() const{
    return m_features_isValid;
}

QString OAIV0_0_39_job_info::getFederationOrigin() const {
    return m_federation_origin;
}
void OAIV0_0_39_job_info::setFederationOrigin(const QString &federation_origin) {
    m_federation_origin = federation_origin;
    m_federation_origin_isSet = true;
}

bool OAIV0_0_39_job_info::is_federation_origin_Set() const{
    return m_federation_origin_isSet;
}

bool OAIV0_0_39_job_info::is_federation_origin_Valid() const{
    return m_federation_origin_isValid;
}

QString OAIV0_0_39_job_info::getFederationSiblingsActive() const {
    return m_federation_siblings_active;
}
void OAIV0_0_39_job_info::setFederationSiblingsActive(const QString &federation_siblings_active) {
    m_federation_siblings_active = federation_siblings_active;
    m_federation_siblings_active_isSet = true;
}

bool OAIV0_0_39_job_info::is_federation_siblings_active_Set() const{
    return m_federation_siblings_active_isSet;
}

bool OAIV0_0_39_job_info::is_federation_siblings_active_Valid() const{
    return m_federation_siblings_active_isValid;
}

QString OAIV0_0_39_job_info::getFederationSiblingsViable() const {
    return m_federation_siblings_viable;
}
void OAIV0_0_39_job_info::setFederationSiblingsViable(const QString &federation_siblings_viable) {
    m_federation_siblings_viable = federation_siblings_viable;
    m_federation_siblings_viable_isSet = true;
}

bool OAIV0_0_39_job_info::is_federation_siblings_viable_Set() const{
    return m_federation_siblings_viable_isSet;
}

bool OAIV0_0_39_job_info::is_federation_siblings_viable_Valid() const{
    return m_federation_siblings_viable_isValid;
}

QList<QString> OAIV0_0_39_job_info::getGresDetail() const {
    return m_gres_detail;
}
void OAIV0_0_39_job_info::setGresDetail(const QList<QString> &gres_detail) {
    m_gres_detail = gres_detail;
    m_gres_detail_isSet = true;
}

bool OAIV0_0_39_job_info::is_gres_detail_Set() const{
    return m_gres_detail_isSet;
}

bool OAIV0_0_39_job_info::is_gres_detail_Valid() const{
    return m_gres_detail_isValid;
}

qint32 OAIV0_0_39_job_info::getGroupId() const {
    return m_group_id;
}
void OAIV0_0_39_job_info::setGroupId(const qint32 &group_id) {
    m_group_id = group_id;
    m_group_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_group_id_Set() const{
    return m_group_id_isSet;
}

bool OAIV0_0_39_job_info::is_group_id_Valid() const{
    return m_group_id_isValid;
}

QString OAIV0_0_39_job_info::getGroupName() const {
    return m_group_name;
}
void OAIV0_0_39_job_info::setGroupName(const QString &group_name) {
    m_group_name = group_name;
    m_group_name_isSet = true;
}

bool OAIV0_0_39_job_info::is_group_name_Set() const{
    return m_group_name_isSet;
}

bool OAIV0_0_39_job_info::is_group_name_Valid() const{
    return m_group_name_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getHetJobId() const {
    return m_het_job_id;
}
void OAIV0_0_39_job_info::setHetJobId(const OAIV0_0_39_uint32_no_val &het_job_id) {
    m_het_job_id = het_job_id;
    m_het_job_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_het_job_id_Set() const{
    return m_het_job_id_isSet;
}

bool OAIV0_0_39_job_info::is_het_job_id_Valid() const{
    return m_het_job_id_isValid;
}

QString OAIV0_0_39_job_info::getHetJobIdSet() const {
    return m_het_job_id_set;
}
void OAIV0_0_39_job_info::setHetJobIdSet(const QString &het_job_id_set) {
    m_het_job_id_set = het_job_id_set;
    m_het_job_id_set_isSet = true;
}

bool OAIV0_0_39_job_info::is_het_job_id_set_Set() const{
    return m_het_job_id_set_isSet;
}

bool OAIV0_0_39_job_info::is_het_job_id_set_Valid() const{
    return m_het_job_id_set_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getHetJobOffset() const {
    return m_het_job_offset;
}
void OAIV0_0_39_job_info::setHetJobOffset(const OAIV0_0_39_uint32_no_val &het_job_offset) {
    m_het_job_offset = het_job_offset;
    m_het_job_offset_isSet = true;
}

bool OAIV0_0_39_job_info::is_het_job_offset_Set() const{
    return m_het_job_offset_isSet;
}

bool OAIV0_0_39_job_info::is_het_job_offset_Valid() const{
    return m_het_job_offset_isValid;
}

qint32 OAIV0_0_39_job_info::getJobId() const {
    return m_job_id;
}
void OAIV0_0_39_job_info::setJobId(const qint32 &job_id) {
    m_job_id = job_id;
    m_job_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_job_id_Set() const{
    return m_job_id_isSet;
}

bool OAIV0_0_39_job_info::is_job_id_Valid() const{
    return m_job_id_isValid;
}

OAIV0_0_39_job_res OAIV0_0_39_job_info::getJobResources() const {
    return m_job_resources;
}
void OAIV0_0_39_job_info::setJobResources(const OAIV0_0_39_job_res &job_resources) {
    m_job_resources = job_resources;
    m_job_resources_isSet = true;
}

bool OAIV0_0_39_job_info::is_job_resources_Set() const{
    return m_job_resources_isSet;
}

bool OAIV0_0_39_job_info::is_job_resources_Valid() const{
    return m_job_resources_isValid;
}

QList<QString> OAIV0_0_39_job_info::getJobSizeStr() const {
    return m_job_size_str;
}
void OAIV0_0_39_job_info::setJobSizeStr(const QList<QString> &job_size_str) {
    m_job_size_str = job_size_str;
    m_job_size_str_isSet = true;
}

bool OAIV0_0_39_job_info::is_job_size_str_Set() const{
    return m_job_size_str_isSet;
}

bool OAIV0_0_39_job_info::is_job_size_str_Valid() const{
    return m_job_size_str_isValid;
}

QString OAIV0_0_39_job_info::getJobState() const {
    return m_job_state;
}
void OAIV0_0_39_job_info::setJobState(const QString &job_state) {
    m_job_state = job_state;
    m_job_state_isSet = true;
}

bool OAIV0_0_39_job_info::is_job_state_Set() const{
    return m_job_state_isSet;
}

bool OAIV0_0_39_job_info::is_job_state_Valid() const{
    return m_job_state_isValid;
}

qint64 OAIV0_0_39_job_info::getLastSchedEvaluation() const {
    return m_last_sched_evaluation;
}
void OAIV0_0_39_job_info::setLastSchedEvaluation(const qint64 &last_sched_evaluation) {
    m_last_sched_evaluation = last_sched_evaluation;
    m_last_sched_evaluation_isSet = true;
}

bool OAIV0_0_39_job_info::is_last_sched_evaluation_Set() const{
    return m_last_sched_evaluation_isSet;
}

bool OAIV0_0_39_job_info::is_last_sched_evaluation_Valid() const{
    return m_last_sched_evaluation_isValid;
}

QString OAIV0_0_39_job_info::getLicenses() const {
    return m_licenses;
}
void OAIV0_0_39_job_info::setLicenses(const QString &licenses) {
    m_licenses = licenses;
    m_licenses_isSet = true;
}

bool OAIV0_0_39_job_info::is_licenses_Set() const{
    return m_licenses_isSet;
}

bool OAIV0_0_39_job_info::is_licenses_Valid() const{
    return m_licenses_isValid;
}

QList<QString> OAIV0_0_39_job_info::getMailType() const {
    return m_mail_type;
}
void OAIV0_0_39_job_info::setMailType(const QList<QString> &mail_type) {
    m_mail_type = mail_type;
    m_mail_type_isSet = true;
}

bool OAIV0_0_39_job_info::is_mail_type_Set() const{
    return m_mail_type_isSet;
}

bool OAIV0_0_39_job_info::is_mail_type_Valid() const{
    return m_mail_type_isValid;
}

QString OAIV0_0_39_job_info::getMailUser() const {
    return m_mail_user;
}
void OAIV0_0_39_job_info::setMailUser(const QString &mail_user) {
    m_mail_user = mail_user;
    m_mail_user_isSet = true;
}

bool OAIV0_0_39_job_info::is_mail_user_Set() const{
    return m_mail_user_isSet;
}

bool OAIV0_0_39_job_info::is_mail_user_Valid() const{
    return m_mail_user_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getMaxCpus() const {
    return m_max_cpus;
}
void OAIV0_0_39_job_info::setMaxCpus(const OAIV0_0_39_uint32_no_val &max_cpus) {
    m_max_cpus = max_cpus;
    m_max_cpus_isSet = true;
}

bool OAIV0_0_39_job_info::is_max_cpus_Set() const{
    return m_max_cpus_isSet;
}

bool OAIV0_0_39_job_info::is_max_cpus_Valid() const{
    return m_max_cpus_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getMaxNodes() const {
    return m_max_nodes;
}
void OAIV0_0_39_job_info::setMaxNodes(const OAIV0_0_39_uint32_no_val &max_nodes) {
    m_max_nodes = max_nodes;
    m_max_nodes_isSet = true;
}

bool OAIV0_0_39_job_info::is_max_nodes_Set() const{
    return m_max_nodes_isSet;
}

bool OAIV0_0_39_job_info::is_max_nodes_Valid() const{
    return m_max_nodes_isValid;
}

QString OAIV0_0_39_job_info::getMcsLabel() const {
    return m_mcs_label;
}
void OAIV0_0_39_job_info::setMcsLabel(const QString &mcs_label) {
    m_mcs_label = mcs_label;
    m_mcs_label_isSet = true;
}

bool OAIV0_0_39_job_info::is_mcs_label_Set() const{
    return m_mcs_label_isSet;
}

bool OAIV0_0_39_job_info::is_mcs_label_Valid() const{
    return m_mcs_label_isValid;
}

QString OAIV0_0_39_job_info::getMemoryPerTres() const {
    return m_memory_per_tres;
}
void OAIV0_0_39_job_info::setMemoryPerTres(const QString &memory_per_tres) {
    m_memory_per_tres = memory_per_tres;
    m_memory_per_tres_isSet = true;
}

bool OAIV0_0_39_job_info::is_memory_per_tres_Set() const{
    return m_memory_per_tres_isSet;
}

bool OAIV0_0_39_job_info::is_memory_per_tres_Valid() const{
    return m_memory_per_tres_isValid;
}

QString OAIV0_0_39_job_info::getName() const {
    return m_name;
}
void OAIV0_0_39_job_info::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIV0_0_39_job_info::is_name_Set() const{
    return m_name_isSet;
}

bool OAIV0_0_39_job_info::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIV0_0_39_job_info::getNetwork() const {
    return m_network;
}
void OAIV0_0_39_job_info::setNetwork(const QString &network) {
    m_network = network;
    m_network_isSet = true;
}

bool OAIV0_0_39_job_info::is_network_Set() const{
    return m_network_isSet;
}

bool OAIV0_0_39_job_info::is_network_Valid() const{
    return m_network_isValid;
}

QString OAIV0_0_39_job_info::getNodes() const {
    return m_nodes;
}
void OAIV0_0_39_job_info::setNodes(const QString &nodes) {
    m_nodes = nodes;
    m_nodes_isSet = true;
}

bool OAIV0_0_39_job_info::is_nodes_Set() const{
    return m_nodes_isSet;
}

bool OAIV0_0_39_job_info::is_nodes_Valid() const{
    return m_nodes_isValid;
}

qint32 OAIV0_0_39_job_info::getNice() const {
    return m_nice;
}
void OAIV0_0_39_job_info::setNice(const qint32 &nice) {
    m_nice = nice;
    m_nice_isSet = true;
}

bool OAIV0_0_39_job_info::is_nice_Set() const{
    return m_nice_isSet;
}

bool OAIV0_0_39_job_info::is_nice_Valid() const{
    return m_nice_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getTasksPerCore() const {
    return m_tasks_per_core;
}
void OAIV0_0_39_job_info::setTasksPerCore(const OAIV0_0_39_uint16_no_val &tasks_per_core) {
    m_tasks_per_core = tasks_per_core;
    m_tasks_per_core_isSet = true;
}

bool OAIV0_0_39_job_info::is_tasks_per_core_Set() const{
    return m_tasks_per_core_isSet;
}

bool OAIV0_0_39_job_info::is_tasks_per_core_Valid() const{
    return m_tasks_per_core_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getTasksPerTres() const {
    return m_tasks_per_tres;
}
void OAIV0_0_39_job_info::setTasksPerTres(const OAIV0_0_39_uint16_no_val &tasks_per_tres) {
    m_tasks_per_tres = tasks_per_tres;
    m_tasks_per_tres_isSet = true;
}

bool OAIV0_0_39_job_info::is_tasks_per_tres_Set() const{
    return m_tasks_per_tres_isSet;
}

bool OAIV0_0_39_job_info::is_tasks_per_tres_Valid() const{
    return m_tasks_per_tres_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getTasksPerNode() const {
    return m_tasks_per_node;
}
void OAIV0_0_39_job_info::setTasksPerNode(const OAIV0_0_39_uint16_no_val &tasks_per_node) {
    m_tasks_per_node = tasks_per_node;
    m_tasks_per_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_tasks_per_node_Set() const{
    return m_tasks_per_node_isSet;
}

bool OAIV0_0_39_job_info::is_tasks_per_node_Valid() const{
    return m_tasks_per_node_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getTasksPerSocket() const {
    return m_tasks_per_socket;
}
void OAIV0_0_39_job_info::setTasksPerSocket(const OAIV0_0_39_uint16_no_val &tasks_per_socket) {
    m_tasks_per_socket = tasks_per_socket;
    m_tasks_per_socket_isSet = true;
}

bool OAIV0_0_39_job_info::is_tasks_per_socket_Set() const{
    return m_tasks_per_socket_isSet;
}

bool OAIV0_0_39_job_info::is_tasks_per_socket_Valid() const{
    return m_tasks_per_socket_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getTasksPerBoard() const {
    return m_tasks_per_board;
}
void OAIV0_0_39_job_info::setTasksPerBoard(const OAIV0_0_39_uint16_no_val &tasks_per_board) {
    m_tasks_per_board = tasks_per_board;
    m_tasks_per_board_isSet = true;
}

bool OAIV0_0_39_job_info::is_tasks_per_board_Set() const{
    return m_tasks_per_board_isSet;
}

bool OAIV0_0_39_job_info::is_tasks_per_board_Valid() const{
    return m_tasks_per_board_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getCpus() const {
    return m_cpus;
}
void OAIV0_0_39_job_info::setCpus(const OAIV0_0_39_uint32_no_val &cpus) {
    m_cpus = cpus;
    m_cpus_isSet = true;
}

bool OAIV0_0_39_job_info::is_cpus_Set() const{
    return m_cpus_isSet;
}

bool OAIV0_0_39_job_info::is_cpus_Valid() const{
    return m_cpus_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getNodeCount() const {
    return m_node_count;
}
void OAIV0_0_39_job_info::setNodeCount(const OAIV0_0_39_uint32_no_val &node_count) {
    m_node_count = node_count;
    m_node_count_isSet = true;
}

bool OAIV0_0_39_job_info::is_node_count_Set() const{
    return m_node_count_isSet;
}

bool OAIV0_0_39_job_info::is_node_count_Valid() const{
    return m_node_count_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getTasks() const {
    return m_tasks;
}
void OAIV0_0_39_job_info::setTasks(const OAIV0_0_39_uint32_no_val &tasks) {
    m_tasks = tasks;
    m_tasks_isSet = true;
}

bool OAIV0_0_39_job_info::is_tasks_Set() const{
    return m_tasks_isSet;
}

bool OAIV0_0_39_job_info::is_tasks_Valid() const{
    return m_tasks_isValid;
}

QString OAIV0_0_39_job_info::getPartition() const {
    return m_partition;
}
void OAIV0_0_39_job_info::setPartition(const QString &partition) {
    m_partition = partition;
    m_partition_isSet = true;
}

bool OAIV0_0_39_job_info::is_partition_Set() const{
    return m_partition_isSet;
}

bool OAIV0_0_39_job_info::is_partition_Valid() const{
    return m_partition_isValid;
}

QString OAIV0_0_39_job_info::getPrefer() const {
    return m_prefer;
}
void OAIV0_0_39_job_info::setPrefer(const QString &prefer) {
    m_prefer = prefer;
    m_prefer_isSet = true;
}

bool OAIV0_0_39_job_info::is_prefer_Set() const{
    return m_prefer_isSet;
}

bool OAIV0_0_39_job_info::is_prefer_Valid() const{
    return m_prefer_isValid;
}

OAIV0_0_39_uint64_no_val OAIV0_0_39_job_info::getMemoryPerCpu() const {
    return m_memory_per_cpu;
}
void OAIV0_0_39_job_info::setMemoryPerCpu(const OAIV0_0_39_uint64_no_val &memory_per_cpu) {
    m_memory_per_cpu = memory_per_cpu;
    m_memory_per_cpu_isSet = true;
}

bool OAIV0_0_39_job_info::is_memory_per_cpu_Set() const{
    return m_memory_per_cpu_isSet;
}

bool OAIV0_0_39_job_info::is_memory_per_cpu_Valid() const{
    return m_memory_per_cpu_isValid;
}

OAIV0_0_39_uint64_no_val OAIV0_0_39_job_info::getMemoryPerNode() const {
    return m_memory_per_node;
}
void OAIV0_0_39_job_info::setMemoryPerNode(const OAIV0_0_39_uint64_no_val &memory_per_node) {
    m_memory_per_node = memory_per_node;
    m_memory_per_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_memory_per_node_Set() const{
    return m_memory_per_node_isSet;
}

bool OAIV0_0_39_job_info::is_memory_per_node_Valid() const{
    return m_memory_per_node_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getMinimumCpusPerNode() const {
    return m_minimum_cpus_per_node;
}
void OAIV0_0_39_job_info::setMinimumCpusPerNode(const OAIV0_0_39_uint16_no_val &minimum_cpus_per_node) {
    m_minimum_cpus_per_node = minimum_cpus_per_node;
    m_minimum_cpus_per_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_minimum_cpus_per_node_Set() const{
    return m_minimum_cpus_per_node_isSet;
}

bool OAIV0_0_39_job_info::is_minimum_cpus_per_node_Valid() const{
    return m_minimum_cpus_per_node_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getMinimumTmpDiskPerNode() const {
    return m_minimum_tmp_disk_per_node;
}
void OAIV0_0_39_job_info::setMinimumTmpDiskPerNode(const OAIV0_0_39_uint32_no_val &minimum_tmp_disk_per_node) {
    m_minimum_tmp_disk_per_node = minimum_tmp_disk_per_node;
    m_minimum_tmp_disk_per_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_minimum_tmp_disk_per_node_Set() const{
    return m_minimum_tmp_disk_per_node_isSet;
}

bool OAIV0_0_39_job_info::is_minimum_tmp_disk_per_node_Valid() const{
    return m_minimum_tmp_disk_per_node_isValid;
}

OAIV0_0_39_job_info_power OAIV0_0_39_job_info::getPower() const {
    return m_power;
}
void OAIV0_0_39_job_info::setPower(const OAIV0_0_39_job_info_power &power) {
    m_power = power;
    m_power_isSet = true;
}

bool OAIV0_0_39_job_info::is_power_Set() const{
    return m_power_isSet;
}

bool OAIV0_0_39_job_info::is_power_Valid() const{
    return m_power_isValid;
}

qint64 OAIV0_0_39_job_info::getPreemptTime() const {
    return m_preempt_time;
}
void OAIV0_0_39_job_info::setPreemptTime(const qint64 &preempt_time) {
    m_preempt_time = preempt_time;
    m_preempt_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_preempt_time_Set() const{
    return m_preempt_time_isSet;
}

bool OAIV0_0_39_job_info::is_preempt_time_Valid() const{
    return m_preempt_time_isValid;
}

qint64 OAIV0_0_39_job_info::getPreemptableTime() const {
    return m_preemptable_time;
}
void OAIV0_0_39_job_info::setPreemptableTime(const qint64 &preemptable_time) {
    m_preemptable_time = preemptable_time;
    m_preemptable_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_preemptable_time_Set() const{
    return m_preemptable_time_isSet;
}

bool OAIV0_0_39_job_info::is_preemptable_time_Valid() const{
    return m_preemptable_time_isValid;
}

qint64 OAIV0_0_39_job_info::getPreSusTime() const {
    return m_pre_sus_time;
}
void OAIV0_0_39_job_info::setPreSusTime(const qint64 &pre_sus_time) {
    m_pre_sus_time = pre_sus_time;
    m_pre_sus_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_pre_sus_time_Set() const{
    return m_pre_sus_time_isSet;
}

bool OAIV0_0_39_job_info::is_pre_sus_time_Valid() const{
    return m_pre_sus_time_isValid;
}

bool OAIV0_0_39_job_info::isHold() const {
    return m_hold;
}
void OAIV0_0_39_job_info::setHold(const bool &hold) {
    m_hold = hold;
    m_hold_isSet = true;
}

bool OAIV0_0_39_job_info::is_hold_Set() const{
    return m_hold_isSet;
}

bool OAIV0_0_39_job_info::is_hold_Valid() const{
    return m_hold_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getPriority() const {
    return m_priority;
}
void OAIV0_0_39_job_info::setPriority(const OAIV0_0_39_uint32_no_val &priority) {
    m_priority = priority;
    m_priority_isSet = true;
}

bool OAIV0_0_39_job_info::is_priority_Set() const{
    return m_priority_isSet;
}

bool OAIV0_0_39_job_info::is_priority_Valid() const{
    return m_priority_isValid;
}

QList<QString> OAIV0_0_39_job_info::getProfile() const {
    return m_profile;
}
void OAIV0_0_39_job_info::setProfile(const QList<QString> &profile) {
    m_profile = profile;
    m_profile_isSet = true;
}

bool OAIV0_0_39_job_info::is_profile_Set() const{
    return m_profile_isSet;
}

bool OAIV0_0_39_job_info::is_profile_Valid() const{
    return m_profile_isValid;
}

QString OAIV0_0_39_job_info::getQos() const {
    return m_qos;
}
void OAIV0_0_39_job_info::setQos(const QString &qos) {
    m_qos = qos;
    m_qos_isSet = true;
}

bool OAIV0_0_39_job_info::is_qos_Set() const{
    return m_qos_isSet;
}

bool OAIV0_0_39_job_info::is_qos_Valid() const{
    return m_qos_isValid;
}

bool OAIV0_0_39_job_info::isReboot() const {
    return m_reboot;
}
void OAIV0_0_39_job_info::setReboot(const bool &reboot) {
    m_reboot = reboot;
    m_reboot_isSet = true;
}

bool OAIV0_0_39_job_info::is_reboot_Set() const{
    return m_reboot_isSet;
}

bool OAIV0_0_39_job_info::is_reboot_Valid() const{
    return m_reboot_isValid;
}

QString OAIV0_0_39_job_info::getRequiredNodes() const {
    return m_required_nodes;
}
void OAIV0_0_39_job_info::setRequiredNodes(const QString &required_nodes) {
    m_required_nodes = required_nodes;
    m_required_nodes_isSet = true;
}

bool OAIV0_0_39_job_info::is_required_nodes_Set() const{
    return m_required_nodes_isSet;
}

bool OAIV0_0_39_job_info::is_required_nodes_Valid() const{
    return m_required_nodes_isValid;
}

qint32 OAIV0_0_39_job_info::getMinimumSwitches() const {
    return m_minimum_switches;
}
void OAIV0_0_39_job_info::setMinimumSwitches(const qint32 &minimum_switches) {
    m_minimum_switches = minimum_switches;
    m_minimum_switches_isSet = true;
}

bool OAIV0_0_39_job_info::is_minimum_switches_Set() const{
    return m_minimum_switches_isSet;
}

bool OAIV0_0_39_job_info::is_minimum_switches_Valid() const{
    return m_minimum_switches_isValid;
}

bool OAIV0_0_39_job_info::isRequeue() const {
    return m_requeue;
}
void OAIV0_0_39_job_info::setRequeue(const bool &requeue) {
    m_requeue = requeue;
    m_requeue_isSet = true;
}

bool OAIV0_0_39_job_info::is_requeue_Set() const{
    return m_requeue_isSet;
}

bool OAIV0_0_39_job_info::is_requeue_Valid() const{
    return m_requeue_isValid;
}

qint64 OAIV0_0_39_job_info::getResizeTime() const {
    return m_resize_time;
}
void OAIV0_0_39_job_info::setResizeTime(const qint64 &resize_time) {
    m_resize_time = resize_time;
    m_resize_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_resize_time_Set() const{
    return m_resize_time_isSet;
}

bool OAIV0_0_39_job_info::is_resize_time_Valid() const{
    return m_resize_time_isValid;
}

qint32 OAIV0_0_39_job_info::getRestartCnt() const {
    return m_restart_cnt;
}
void OAIV0_0_39_job_info::setRestartCnt(const qint32 &restart_cnt) {
    m_restart_cnt = restart_cnt;
    m_restart_cnt_isSet = true;
}

bool OAIV0_0_39_job_info::is_restart_cnt_Set() const{
    return m_restart_cnt_isSet;
}

bool OAIV0_0_39_job_info::is_restart_cnt_Valid() const{
    return m_restart_cnt_isValid;
}

QString OAIV0_0_39_job_info::getResvName() const {
    return m_resv_name;
}
void OAIV0_0_39_job_info::setResvName(const QString &resv_name) {
    m_resv_name = resv_name;
    m_resv_name_isSet = true;
}

bool OAIV0_0_39_job_info::is_resv_name_Set() const{
    return m_resv_name_isSet;
}

bool OAIV0_0_39_job_info::is_resv_name_Valid() const{
    return m_resv_name_isValid;
}

QString OAIV0_0_39_job_info::getScheduledNodes() const {
    return m_scheduled_nodes;
}
void OAIV0_0_39_job_info::setScheduledNodes(const QString &scheduled_nodes) {
    m_scheduled_nodes = scheduled_nodes;
    m_scheduled_nodes_isSet = true;
}

bool OAIV0_0_39_job_info::is_scheduled_nodes_Set() const{
    return m_scheduled_nodes_isSet;
}

bool OAIV0_0_39_job_info::is_scheduled_nodes_Valid() const{
    return m_scheduled_nodes_isValid;
}

QString OAIV0_0_39_job_info::getSelinuxContext() const {
    return m_selinux_context;
}
void OAIV0_0_39_job_info::setSelinuxContext(const QString &selinux_context) {
    m_selinux_context = selinux_context;
    m_selinux_context_isSet = true;
}

bool OAIV0_0_39_job_info::is_selinux_context_Set() const{
    return m_selinux_context_isSet;
}

bool OAIV0_0_39_job_info::is_selinux_context_Valid() const{
    return m_selinux_context_isValid;
}

QList<QString> OAIV0_0_39_job_info::getShared() const {
    return m_shared;
}
void OAIV0_0_39_job_info::setShared(const QList<QString> &shared) {
    m_shared = shared;
    m_shared_isSet = true;
}

bool OAIV0_0_39_job_info::is_shared_Set() const{
    return m_shared_isSet;
}

bool OAIV0_0_39_job_info::is_shared_Valid() const{
    return m_shared_isValid;
}

QList<QString> OAIV0_0_39_job_info::getExclusive() const {
    return m_exclusive;
}
void OAIV0_0_39_job_info::setExclusive(const QList<QString> &exclusive) {
    m_exclusive = exclusive;
    m_exclusive_isSet = true;
}

bool OAIV0_0_39_job_info::is_exclusive_Set() const{
    return m_exclusive_isSet;
}

bool OAIV0_0_39_job_info::is_exclusive_Valid() const{
    return m_exclusive_isValid;
}

bool OAIV0_0_39_job_info::isOversubscribe() const {
    return m_oversubscribe;
}
void OAIV0_0_39_job_info::setOversubscribe(const bool &oversubscribe) {
    m_oversubscribe = oversubscribe;
    m_oversubscribe_isSet = true;
}

bool OAIV0_0_39_job_info::is_oversubscribe_Set() const{
    return m_oversubscribe_isSet;
}

bool OAIV0_0_39_job_info::is_oversubscribe_Valid() const{
    return m_oversubscribe_isValid;
}

QList<QString> OAIV0_0_39_job_info::getShowFlags() const {
    return m_show_flags;
}
void OAIV0_0_39_job_info::setShowFlags(const QList<QString> &show_flags) {
    m_show_flags = show_flags;
    m_show_flags_isSet = true;
}

bool OAIV0_0_39_job_info::is_show_flags_Set() const{
    return m_show_flags_isSet;
}

bool OAIV0_0_39_job_info::is_show_flags_Valid() const{
    return m_show_flags_isValid;
}

qint32 OAIV0_0_39_job_info::getSocketsPerBoard() const {
    return m_sockets_per_board;
}
void OAIV0_0_39_job_info::setSocketsPerBoard(const qint32 &sockets_per_board) {
    m_sockets_per_board = sockets_per_board;
    m_sockets_per_board_isSet = true;
}

bool OAIV0_0_39_job_info::is_sockets_per_board_Set() const{
    return m_sockets_per_board_isSet;
}

bool OAIV0_0_39_job_info::is_sockets_per_board_Valid() const{
    return m_sockets_per_board_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getSocketsPerNode() const {
    return m_sockets_per_node;
}
void OAIV0_0_39_job_info::setSocketsPerNode(const OAIV0_0_39_uint16_no_val &sockets_per_node) {
    m_sockets_per_node = sockets_per_node;
    m_sockets_per_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_sockets_per_node_Set() const{
    return m_sockets_per_node_isSet;
}

bool OAIV0_0_39_job_info::is_sockets_per_node_Valid() const{
    return m_sockets_per_node_isValid;
}

qint64 OAIV0_0_39_job_info::getStartTime() const {
    return m_start_time;
}
void OAIV0_0_39_job_info::setStartTime(const qint64 &start_time) {
    m_start_time = start_time;
    m_start_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_start_time_Set() const{
    return m_start_time_isSet;
}

bool OAIV0_0_39_job_info::is_start_time_Valid() const{
    return m_start_time_isValid;
}

QString OAIV0_0_39_job_info::getStateDescription() const {
    return m_state_description;
}
void OAIV0_0_39_job_info::setStateDescription(const QString &state_description) {
    m_state_description = state_description;
    m_state_description_isSet = true;
}

bool OAIV0_0_39_job_info::is_state_description_Set() const{
    return m_state_description_isSet;
}

bool OAIV0_0_39_job_info::is_state_description_Valid() const{
    return m_state_description_isValid;
}

QString OAIV0_0_39_job_info::getStateReason() const {
    return m_state_reason;
}
void OAIV0_0_39_job_info::setStateReason(const QString &state_reason) {
    m_state_reason = state_reason;
    m_state_reason_isSet = true;
}

bool OAIV0_0_39_job_info::is_state_reason_Set() const{
    return m_state_reason_isSet;
}

bool OAIV0_0_39_job_info::is_state_reason_Valid() const{
    return m_state_reason_isValid;
}

QString OAIV0_0_39_job_info::getStandardError() const {
    return m_standard_error;
}
void OAIV0_0_39_job_info::setStandardError(const QString &standard_error) {
    m_standard_error = standard_error;
    m_standard_error_isSet = true;
}

bool OAIV0_0_39_job_info::is_standard_error_Set() const{
    return m_standard_error_isSet;
}

bool OAIV0_0_39_job_info::is_standard_error_Valid() const{
    return m_standard_error_isValid;
}

QString OAIV0_0_39_job_info::getStandardInput() const {
    return m_standard_input;
}
void OAIV0_0_39_job_info::setStandardInput(const QString &standard_input) {
    m_standard_input = standard_input;
    m_standard_input_isSet = true;
}

bool OAIV0_0_39_job_info::is_standard_input_Set() const{
    return m_standard_input_isSet;
}

bool OAIV0_0_39_job_info::is_standard_input_Valid() const{
    return m_standard_input_isValid;
}

QString OAIV0_0_39_job_info::getStandardOutput() const {
    return m_standard_output;
}
void OAIV0_0_39_job_info::setStandardOutput(const QString &standard_output) {
    m_standard_output = standard_output;
    m_standard_output_isSet = true;
}

bool OAIV0_0_39_job_info::is_standard_output_Set() const{
    return m_standard_output_isSet;
}

bool OAIV0_0_39_job_info::is_standard_output_Valid() const{
    return m_standard_output_isValid;
}

qint64 OAIV0_0_39_job_info::getSubmitTime() const {
    return m_submit_time;
}
void OAIV0_0_39_job_info::setSubmitTime(const qint64 &submit_time) {
    m_submit_time = submit_time;
    m_submit_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_submit_time_Set() const{
    return m_submit_time_isSet;
}

bool OAIV0_0_39_job_info::is_submit_time_Valid() const{
    return m_submit_time_isValid;
}

qint64 OAIV0_0_39_job_info::getSuspendTime() const {
    return m_suspend_time;
}
void OAIV0_0_39_job_info::setSuspendTime(const qint64 &suspend_time) {
    m_suspend_time = suspend_time;
    m_suspend_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_suspend_time_Set() const{
    return m_suspend_time_isSet;
}

bool OAIV0_0_39_job_info::is_suspend_time_Valid() const{
    return m_suspend_time_isValid;
}

QString OAIV0_0_39_job_info::getSystemComment() const {
    return m_system_comment;
}
void OAIV0_0_39_job_info::setSystemComment(const QString &system_comment) {
    m_system_comment = system_comment;
    m_system_comment_isSet = true;
}

bool OAIV0_0_39_job_info::is_system_comment_Set() const{
    return m_system_comment_isSet;
}

bool OAIV0_0_39_job_info::is_system_comment_Valid() const{
    return m_system_comment_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getTimeLimit() const {
    return m_time_limit;
}
void OAIV0_0_39_job_info::setTimeLimit(const OAIV0_0_39_uint32_no_val &time_limit) {
    m_time_limit = time_limit;
    m_time_limit_isSet = true;
}

bool OAIV0_0_39_job_info::is_time_limit_Set() const{
    return m_time_limit_isSet;
}

bool OAIV0_0_39_job_info::is_time_limit_Valid() const{
    return m_time_limit_isValid;
}

OAIV0_0_39_uint32_no_val OAIV0_0_39_job_info::getTimeMinimum() const {
    return m_time_minimum;
}
void OAIV0_0_39_job_info::setTimeMinimum(const OAIV0_0_39_uint32_no_val &time_minimum) {
    m_time_minimum = time_minimum;
    m_time_minimum_isSet = true;
}

bool OAIV0_0_39_job_info::is_time_minimum_Set() const{
    return m_time_minimum_isSet;
}

bool OAIV0_0_39_job_info::is_time_minimum_Valid() const{
    return m_time_minimum_isValid;
}

OAIV0_0_39_uint16_no_val OAIV0_0_39_job_info::getThreadsPerCore() const {
    return m_threads_per_core;
}
void OAIV0_0_39_job_info::setThreadsPerCore(const OAIV0_0_39_uint16_no_val &threads_per_core) {
    m_threads_per_core = threads_per_core;
    m_threads_per_core_isSet = true;
}

bool OAIV0_0_39_job_info::is_threads_per_core_Set() const{
    return m_threads_per_core_isSet;
}

bool OAIV0_0_39_job_info::is_threads_per_core_Valid() const{
    return m_threads_per_core_isValid;
}

QString OAIV0_0_39_job_info::getTresBind() const {
    return m_tres_bind;
}
void OAIV0_0_39_job_info::setTresBind(const QString &tres_bind) {
    m_tres_bind = tres_bind;
    m_tres_bind_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_bind_Set() const{
    return m_tres_bind_isSet;
}

bool OAIV0_0_39_job_info::is_tres_bind_Valid() const{
    return m_tres_bind_isValid;
}

QString OAIV0_0_39_job_info::getTresFreq() const {
    return m_tres_freq;
}
void OAIV0_0_39_job_info::setTresFreq(const QString &tres_freq) {
    m_tres_freq = tres_freq;
    m_tres_freq_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_freq_Set() const{
    return m_tres_freq_isSet;
}

bool OAIV0_0_39_job_info::is_tres_freq_Valid() const{
    return m_tres_freq_isValid;
}

QString OAIV0_0_39_job_info::getTresPerJob() const {
    return m_tres_per_job;
}
void OAIV0_0_39_job_info::setTresPerJob(const QString &tres_per_job) {
    m_tres_per_job = tres_per_job;
    m_tres_per_job_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_per_job_Set() const{
    return m_tres_per_job_isSet;
}

bool OAIV0_0_39_job_info::is_tres_per_job_Valid() const{
    return m_tres_per_job_isValid;
}

QString OAIV0_0_39_job_info::getTresPerNode() const {
    return m_tres_per_node;
}
void OAIV0_0_39_job_info::setTresPerNode(const QString &tres_per_node) {
    m_tres_per_node = tres_per_node;
    m_tres_per_node_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_per_node_Set() const{
    return m_tres_per_node_isSet;
}

bool OAIV0_0_39_job_info::is_tres_per_node_Valid() const{
    return m_tres_per_node_isValid;
}

QString OAIV0_0_39_job_info::getTresPerSocket() const {
    return m_tres_per_socket;
}
void OAIV0_0_39_job_info::setTresPerSocket(const QString &tres_per_socket) {
    m_tres_per_socket = tres_per_socket;
    m_tres_per_socket_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_per_socket_Set() const{
    return m_tres_per_socket_isSet;
}

bool OAIV0_0_39_job_info::is_tres_per_socket_Valid() const{
    return m_tres_per_socket_isValid;
}

QString OAIV0_0_39_job_info::getTresPerTask() const {
    return m_tres_per_task;
}
void OAIV0_0_39_job_info::setTresPerTask(const QString &tres_per_task) {
    m_tres_per_task = tres_per_task;
    m_tres_per_task_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_per_task_Set() const{
    return m_tres_per_task_isSet;
}

bool OAIV0_0_39_job_info::is_tres_per_task_Valid() const{
    return m_tres_per_task_isValid;
}

QString OAIV0_0_39_job_info::getTresReqStr() const {
    return m_tres_req_str;
}
void OAIV0_0_39_job_info::setTresReqStr(const QString &tres_req_str) {
    m_tres_req_str = tres_req_str;
    m_tres_req_str_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_req_str_Set() const{
    return m_tres_req_str_isSet;
}

bool OAIV0_0_39_job_info::is_tres_req_str_Valid() const{
    return m_tres_req_str_isValid;
}

QString OAIV0_0_39_job_info::getTresAllocStr() const {
    return m_tres_alloc_str;
}
void OAIV0_0_39_job_info::setTresAllocStr(const QString &tres_alloc_str) {
    m_tres_alloc_str = tres_alloc_str;
    m_tres_alloc_str_isSet = true;
}

bool OAIV0_0_39_job_info::is_tres_alloc_str_Set() const{
    return m_tres_alloc_str_isSet;
}

bool OAIV0_0_39_job_info::is_tres_alloc_str_Valid() const{
    return m_tres_alloc_str_isValid;
}

qint32 OAIV0_0_39_job_info::getUserId() const {
    return m_user_id;
}
void OAIV0_0_39_job_info::setUserId(const qint32 &user_id) {
    m_user_id = user_id;
    m_user_id_isSet = true;
}

bool OAIV0_0_39_job_info::is_user_id_Set() const{
    return m_user_id_isSet;
}

bool OAIV0_0_39_job_info::is_user_id_Valid() const{
    return m_user_id_isValid;
}

QString OAIV0_0_39_job_info::getUserName() const {
    return m_user_name;
}
void OAIV0_0_39_job_info::setUserName(const QString &user_name) {
    m_user_name = user_name;
    m_user_name_isSet = true;
}

bool OAIV0_0_39_job_info::is_user_name_Set() const{
    return m_user_name_isSet;
}

bool OAIV0_0_39_job_info::is_user_name_Valid() const{
    return m_user_name_isValid;
}

qint32 OAIV0_0_39_job_info::getMaximumSwitchWaitTime() const {
    return m_maximum_switch_wait_time;
}
void OAIV0_0_39_job_info::setMaximumSwitchWaitTime(const qint32 &maximum_switch_wait_time) {
    m_maximum_switch_wait_time = maximum_switch_wait_time;
    m_maximum_switch_wait_time_isSet = true;
}

bool OAIV0_0_39_job_info::is_maximum_switch_wait_time_Set() const{
    return m_maximum_switch_wait_time_isSet;
}

bool OAIV0_0_39_job_info::is_maximum_switch_wait_time_Valid() const{
    return m_maximum_switch_wait_time_isValid;
}

QString OAIV0_0_39_job_info::getWckey() const {
    return m_wckey;
}
void OAIV0_0_39_job_info::setWckey(const QString &wckey) {
    m_wckey = wckey;
    m_wckey_isSet = true;
}

bool OAIV0_0_39_job_info::is_wckey_Set() const{
    return m_wckey_isSet;
}

bool OAIV0_0_39_job_info::is_wckey_Valid() const{
    return m_wckey_isValid;
}

QString OAIV0_0_39_job_info::getCurrentWorkingDirectory() const {
    return m_current_working_directory;
}
void OAIV0_0_39_job_info::setCurrentWorkingDirectory(const QString &current_working_directory) {
    m_current_working_directory = current_working_directory;
    m_current_working_directory_isSet = true;
}

bool OAIV0_0_39_job_info::is_current_working_directory_Set() const{
    return m_current_working_directory_isSet;
}

bool OAIV0_0_39_job_info::is_current_working_directory_Valid() const{
    return m_current_working_directory_isValid;
}

bool OAIV0_0_39_job_info::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_accrue_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_admin_comment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_allocating_node_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_array_job_id.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_array_task_id.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_array_max_tasks.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_array_task_string_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_association_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_batch_features_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_batch_flag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_batch_host_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_flags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_burst_buffer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_burst_buffer_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_features_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_command_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_comment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_container_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_container_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_contiguous_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_core_spec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_thread_spec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cores_per_socket.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_billable_tres.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpus_per_task.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpu_frequency_minimum.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpu_frequency_maximum.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpu_frequency_governor.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpus_per_tres_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cron_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_deadline_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_delay_boot.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_dependency_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_derived_exit_code.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_eligible_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_excluded_nodes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_exit_code.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_extra_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_failed_node_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_features_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_federation_origin_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_federation_siblings_active_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_federation_siblings_viable_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gres_detail.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_group_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_group_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_het_job_id.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_het_job_id_set_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_het_job_offset.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_job_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_job_resources.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_job_size_str.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_job_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_sched_evaluation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_licenses_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mail_type.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_mail_user_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_cpus.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_nodes.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_mcs_label_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_per_tres_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nodes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nice_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tasks_per_core.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tasks_per_tres.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tasks_per_node.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tasks_per_socket.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tasks_per_board.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpus.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_node_count.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tasks.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_partition_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_prefer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_per_cpu.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_per_node.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimum_cpus_per_node.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimum_tmp_disk_per_node.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_power.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_preempt_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_preemptable_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pre_sus_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_priority.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_profile.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_qos_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reboot_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_required_nodes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimum_switches_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requeue_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resize_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_restart_cnt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resv_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduled_nodes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_selinux_context_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_shared.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_exclusive.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_oversubscribe_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_show_flags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_sockets_per_board_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sockets_per_node.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_standard_error_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_standard_input_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_standard_output_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_submit_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_suspend_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_system_comment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_limit.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_minimum.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_threads_per_core.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_bind_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_freq_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_per_job_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_per_node_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_per_socket_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_per_task_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_req_str_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tres_alloc_str_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_switch_wait_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wckey_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_current_working_directory_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIV0_0_39_job_info::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace hm:slurm:client
