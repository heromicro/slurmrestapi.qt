/**
 * Slurm REST API
 * API to access and control Slurm
 *
 * The version of the OpenAPI document: Slurm-24.05.5&openapi/dbv0.0.39&openapi/slurmctld&openapi/slurmdbd&openapi/v0.0.39
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISlurmApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace hm:slurm:client {

OAISlurmApi::OAISlurmApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAISlurmApi::~OAISlurmApi() {
}

void OAISlurmApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("slurmV0039CancelJob", defaultConf);
    _serverIndices.insert("slurmV0039CancelJob", 0);
    _serverConfigs.insert("slurmV0039DeleteNode", defaultConf);
    _serverIndices.insert("slurmV0039DeleteNode", 0);
    _serverConfigs.insert("slurmV0039Diag", defaultConf);
    _serverIndices.insert("slurmV0039Diag", 0);
    _serverConfigs.insert("slurmV0039GetJob", defaultConf);
    _serverIndices.insert("slurmV0039GetJob", 0);
    _serverConfigs.insert("slurmV0039GetJobs", defaultConf);
    _serverIndices.insert("slurmV0039GetJobs", 0);
    _serverConfigs.insert("slurmV0039GetNode", defaultConf);
    _serverIndices.insert("slurmV0039GetNode", 0);
    _serverConfigs.insert("slurmV0039GetNodes", defaultConf);
    _serverIndices.insert("slurmV0039GetNodes", 0);
    _serverConfigs.insert("slurmV0039GetPartition", defaultConf);
    _serverIndices.insert("slurmV0039GetPartition", 0);
    _serverConfigs.insert("slurmV0039GetPartitions", defaultConf);
    _serverIndices.insert("slurmV0039GetPartitions", 0);
    _serverConfigs.insert("slurmV0039GetReservation", defaultConf);
    _serverIndices.insert("slurmV0039GetReservation", 0);
    _serverConfigs.insert("slurmV0039GetReservations", defaultConf);
    _serverIndices.insert("slurmV0039GetReservations", 0);
    _serverConfigs.insert("slurmV0039Ping", defaultConf);
    _serverIndices.insert("slurmV0039Ping", 0);
    _serverConfigs.insert("slurmV0039SlurmctldGetLicenses", defaultConf);
    _serverIndices.insert("slurmV0039SlurmctldGetLicenses", 0);
    _serverConfigs.insert("slurmV0039SubmitJob", defaultConf);
    _serverIndices.insert("slurmV0039SubmitJob", 0);
    _serverConfigs.insert("slurmV0039UpdateJob", defaultConf);
    _serverIndices.insert("slurmV0039UpdateJob", 0);
    _serverConfigs.insert("slurmV0039UpdateNode", defaultConf);
    _serverIndices.insert("slurmV0039UpdateNode", 0);
    _serverConfigs.insert("slurmV0040DeleteJob", defaultConf);
    _serverIndices.insert("slurmV0040DeleteJob", 0);
    _serverConfigs.insert("slurmV0040DeleteJobs", defaultConf);
    _serverIndices.insert("slurmV0040DeleteJobs", 0);
    _serverConfigs.insert("slurmV0040DeleteNode", defaultConf);
    _serverIndices.insert("slurmV0040DeleteNode", 0);
    _serverConfigs.insert("slurmV0040GetDiag", defaultConf);
    _serverIndices.insert("slurmV0040GetDiag", 0);
    _serverConfigs.insert("slurmV0040GetJob", defaultConf);
    _serverIndices.insert("slurmV0040GetJob", 0);
    _serverConfigs.insert("slurmV0040GetJobs", defaultConf);
    _serverIndices.insert("slurmV0040GetJobs", 0);
    _serverConfigs.insert("slurmV0040GetJobsState", defaultConf);
    _serverIndices.insert("slurmV0040GetJobsState", 0);
    _serverConfigs.insert("slurmV0040GetLicenses", defaultConf);
    _serverIndices.insert("slurmV0040GetLicenses", 0);
    _serverConfigs.insert("slurmV0040GetNode", defaultConf);
    _serverIndices.insert("slurmV0040GetNode", 0);
    _serverConfigs.insert("slurmV0040GetNodes", defaultConf);
    _serverIndices.insert("slurmV0040GetNodes", 0);
    _serverConfigs.insert("slurmV0040GetPartition", defaultConf);
    _serverIndices.insert("slurmV0040GetPartition", 0);
    _serverConfigs.insert("slurmV0040GetPartitions", defaultConf);
    _serverIndices.insert("slurmV0040GetPartitions", 0);
    _serverConfigs.insert("slurmV0040GetPing", defaultConf);
    _serverIndices.insert("slurmV0040GetPing", 0);
    _serverConfigs.insert("slurmV0040GetReconfigure", defaultConf);
    _serverIndices.insert("slurmV0040GetReconfigure", 0);
    _serverConfigs.insert("slurmV0040GetReservation", defaultConf);
    _serverIndices.insert("slurmV0040GetReservation", 0);
    _serverConfigs.insert("slurmV0040GetReservations", defaultConf);
    _serverIndices.insert("slurmV0040GetReservations", 0);
    _serverConfigs.insert("slurmV0040GetShares", defaultConf);
    _serverIndices.insert("slurmV0040GetShares", 0);
    _serverConfigs.insert("slurmV0040PostJob", defaultConf);
    _serverIndices.insert("slurmV0040PostJob", 0);
    _serverConfigs.insert("slurmV0040PostJobSubmit", defaultConf);
    _serverIndices.insert("slurmV0040PostJobSubmit", 0);
    _serverConfigs.insert("slurmV0040PostNode", defaultConf);
    _serverIndices.insert("slurmV0040PostNode", 0);
    _serverConfigs.insert("slurmV0041DeleteJob", defaultConf);
    _serverIndices.insert("slurmV0041DeleteJob", 0);
    _serverConfigs.insert("slurmV0041DeleteJobs", defaultConf);
    _serverIndices.insert("slurmV0041DeleteJobs", 0);
    _serverConfigs.insert("slurmV0041DeleteNode", defaultConf);
    _serverIndices.insert("slurmV0041DeleteNode", 0);
    _serverConfigs.insert("slurmV0041GetDiag", defaultConf);
    _serverIndices.insert("slurmV0041GetDiag", 0);
    _serverConfigs.insert("slurmV0041GetJob", defaultConf);
    _serverIndices.insert("slurmV0041GetJob", 0);
    _serverConfigs.insert("slurmV0041GetJobs", defaultConf);
    _serverIndices.insert("slurmV0041GetJobs", 0);
    _serverConfigs.insert("slurmV0041GetJobsState", defaultConf);
    _serverIndices.insert("slurmV0041GetJobsState", 0);
    _serverConfigs.insert("slurmV0041GetLicenses", defaultConf);
    _serverIndices.insert("slurmV0041GetLicenses", 0);
    _serverConfigs.insert("slurmV0041GetNode", defaultConf);
    _serverIndices.insert("slurmV0041GetNode", 0);
    _serverConfigs.insert("slurmV0041GetNodes", defaultConf);
    _serverIndices.insert("slurmV0041GetNodes", 0);
    _serverConfigs.insert("slurmV0041GetPartition", defaultConf);
    _serverIndices.insert("slurmV0041GetPartition", 0);
    _serverConfigs.insert("slurmV0041GetPartitions", defaultConf);
    _serverIndices.insert("slurmV0041GetPartitions", 0);
    _serverConfigs.insert("slurmV0041GetPing", defaultConf);
    _serverIndices.insert("slurmV0041GetPing", 0);
    _serverConfigs.insert("slurmV0041GetReconfigure", defaultConf);
    _serverIndices.insert("slurmV0041GetReconfigure", 0);
    _serverConfigs.insert("slurmV0041GetReservation", defaultConf);
    _serverIndices.insert("slurmV0041GetReservation", 0);
    _serverConfigs.insert("slurmV0041GetReservations", defaultConf);
    _serverIndices.insert("slurmV0041GetReservations", 0);
    _serverConfigs.insert("slurmV0041GetShares", defaultConf);
    _serverIndices.insert("slurmV0041GetShares", 0);
    _serverConfigs.insert("slurmV0041PostJob", defaultConf);
    _serverIndices.insert("slurmV0041PostJob", 0);
    _serverConfigs.insert("slurmV0041PostJobAllocate", defaultConf);
    _serverIndices.insert("slurmV0041PostJobAllocate", 0);
    _serverConfigs.insert("slurmV0041PostJobSubmit", defaultConf);
    _serverIndices.insert("slurmV0041PostJobSubmit", 0);
    _serverConfigs.insert("slurmV0041PostNode", defaultConf);
    _serverIndices.insert("slurmV0041PostNode", 0);
    _serverConfigs.insert("slurmdbV0039AddClusters", defaultConf);
    _serverIndices.insert("slurmdbV0039AddClusters", 0);
    _serverConfigs.insert("slurmdbV0039AddWckeys", defaultConf);
    _serverIndices.insert("slurmdbV0039AddWckeys", 0);
    _serverConfigs.insert("slurmdbV0039DeleteAccount", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteAccount", 0);
    _serverConfigs.insert("slurmdbV0039DeleteAssociation", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteAssociation", 0);
    _serverConfigs.insert("slurmdbV0039DeleteAssociations", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteAssociations", 0);
    _serverConfigs.insert("slurmdbV0039DeleteCluster", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteCluster", 0);
    _serverConfigs.insert("slurmdbV0039DeleteQos", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteQos", 0);
    _serverConfigs.insert("slurmdbV0039DeleteUser", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteUser", 0);
    _serverConfigs.insert("slurmdbV0039DeleteWckey", defaultConf);
    _serverIndices.insert("slurmdbV0039DeleteWckey", 0);
    _serverConfigs.insert("slurmdbV0039Diag", defaultConf);
    _serverIndices.insert("slurmdbV0039Diag", 0);
    _serverConfigs.insert("slurmdbV0039GetAccount", defaultConf);
    _serverIndices.insert("slurmdbV0039GetAccount", 0);
    _serverConfigs.insert("slurmdbV0039GetAccounts", defaultConf);
    _serverIndices.insert("slurmdbV0039GetAccounts", 0);
    _serverConfigs.insert("slurmdbV0039GetAssociation", defaultConf);
    _serverIndices.insert("slurmdbV0039GetAssociation", 0);
    _serverConfigs.insert("slurmdbV0039GetAssociations", defaultConf);
    _serverIndices.insert("slurmdbV0039GetAssociations", 0);
    _serverConfigs.insert("slurmdbV0039GetCluster", defaultConf);
    _serverIndices.insert("slurmdbV0039GetCluster", 0);
    _serverConfigs.insert("slurmdbV0039GetClusters", defaultConf);
    _serverIndices.insert("slurmdbV0039GetClusters", 0);
    _serverConfigs.insert("slurmdbV0039GetConfig", defaultConf);
    _serverIndices.insert("slurmdbV0039GetConfig", 0);
    _serverConfigs.insert("slurmdbV0039GetJob", defaultConf);
    _serverIndices.insert("slurmdbV0039GetJob", 0);
    _serverConfigs.insert("slurmdbV0039GetJobs", defaultConf);
    _serverIndices.insert("slurmdbV0039GetJobs", 0);
    _serverConfigs.insert("slurmdbV0039GetQos", defaultConf);
    _serverIndices.insert("slurmdbV0039GetQos", 0);
    _serverConfigs.insert("slurmdbV0039GetSingleQos", defaultConf);
    _serverIndices.insert("slurmdbV0039GetSingleQos", 0);
    _serverConfigs.insert("slurmdbV0039GetTres", defaultConf);
    _serverIndices.insert("slurmdbV0039GetTres", 0);
    _serverConfigs.insert("slurmdbV0039GetUser", defaultConf);
    _serverIndices.insert("slurmdbV0039GetUser", 0);
    _serverConfigs.insert("slurmdbV0039GetUsers", defaultConf);
    _serverIndices.insert("slurmdbV0039GetUsers", 0);
    _serverConfigs.insert("slurmdbV0039GetWckey", defaultConf);
    _serverIndices.insert("slurmdbV0039GetWckey", 0);
    _serverConfigs.insert("slurmdbV0039GetWckeys", defaultConf);
    _serverIndices.insert("slurmdbV0039GetWckeys", 0);
    _serverConfigs.insert("slurmdbV0039SetConfig", defaultConf);
    _serverIndices.insert("slurmdbV0039SetConfig", 0);
    _serverConfigs.insert("slurmdbV0039UpdateAccounts", defaultConf);
    _serverIndices.insert("slurmdbV0039UpdateAccounts", 0);
    _serverConfigs.insert("slurmdbV0039UpdateAssociations", defaultConf);
    _serverIndices.insert("slurmdbV0039UpdateAssociations", 0);
    _serverConfigs.insert("slurmdbV0039UpdateQos", defaultConf);
    _serverIndices.insert("slurmdbV0039UpdateQos", 0);
    _serverConfigs.insert("slurmdbV0039UpdateTres", defaultConf);
    _serverIndices.insert("slurmdbV0039UpdateTres", 0);
    _serverConfigs.insert("slurmdbV0039UpdateUsers", defaultConf);
    _serverIndices.insert("slurmdbV0039UpdateUsers", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAISlurmApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAISlurmApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAISlurmApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAISlurmApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAISlurmApi::setUsername(const QString &username) {
    _username = username;
}

void OAISlurmApi::setPassword(const QString &password) {
    _password = password;
}


void OAISlurmApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAISlurmApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAISlurmApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAISlurmApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISlurmApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISlurmApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAISlurmApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAISlurmApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAISlurmApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAISlurmApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAISlurmApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAISlurmApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAISlurmApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAISlurmApi::slurmV0039CancelJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<QString> &signal) {
    QString fullPath = QString(_serverConfigs["slurmV0039CancelJob"][_serverIndices.value("slurmV0039CancelJob")].URL()+"/slurm/v0.0.39/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (signal.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "signal", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("signal")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(signal.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039CancelJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039CancelJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039CancelJobSignal(output);
        Q_EMIT slurmV0039CancelJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039CancelJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039CancelJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039CancelJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039CancelJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039DeleteNode(const QString &node_name) {
    QString fullPath = QString(_serverConfigs["slurmV0039DeleteNode"][_serverIndices.value("slurmV0039DeleteNode")].URL()+"/slurm/v0.0.39/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039DeleteNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039DeleteNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039DeleteNodeSignal(output);
        Q_EMIT slurmV0039DeleteNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039DeleteNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039DeleteNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039DeleteNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039DeleteNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039Diag() {
    QString fullPath = QString(_serverConfigs["slurmV0039Diag"][_serverIndices.value("slurmV0039Diag")].URL()+"/slurm/v0.0.39/diag");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039DiagCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039DiagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_diag output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039DiagSignal(output);
        Q_EMIT slurmV0039DiagSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039DiagSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039DiagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039DiagSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039DiagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetJob(const QString &job_id) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetJob"][_serverIndices.value("slurmV0039GetJob")].URL()+"/slurm/v0.0.39/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_jobs_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetJobSignal(output);
        Q_EMIT slurmV0039GetJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetJobs(const ::hm:slurm:client::OptionalParam<qint64> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetJobs"][_serverIndices.value("slurmV0039GetJobs")].URL()+"/slurm/v0.0.39/jobs");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetJobsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_jobs_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetJobsSignal(output);
        Q_EMIT slurmV0039GetJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetJobsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetJobsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetNode(const QString &node_name) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetNode"][_serverIndices.value("slurmV0039GetNode")].URL()+"/slurm/v0.0.39/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_nodes_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetNodeSignal(output);
        Q_EMIT slurmV0039GetNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetNodes(const ::hm:slurm:client::OptionalParam<qint64> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetNodes"][_serverIndices.value("slurmV0039GetNodes")].URL()+"/slurm/v0.0.39/nodes");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetNodesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetNodesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_nodes_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetNodesSignal(output);
        Q_EMIT slurmV0039GetNodesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetNodesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetNodesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetNodesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetNodesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetPartition(const QString &partition_name, const ::hm:slurm:client::OptionalParam<qint64> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetPartition"][_serverIndices.value("slurmV0039GetPartition")].URL()+"/slurm/v0.0.39/partition/{partition_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString partition_namePathParam("{");
        partition_namePathParam.append("partition_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "partition_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"partition_name"+pathSuffix : pathPrefix;
        fullPath.replace(partition_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetPartitionCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetPartitionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_partitions_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetPartitionSignal(output);
        Q_EMIT slurmV0039GetPartitionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetPartitionSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetPartitionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetPartitionSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetPartitionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetPartitions(const ::hm:slurm:client::OptionalParam<qint64> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetPartitions"][_serverIndices.value("slurmV0039GetPartitions")].URL()+"/slurm/v0.0.39/partitions");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetPartitionsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetPartitionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_partitions_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetPartitionsSignal(output);
        Q_EMIT slurmV0039GetPartitionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetPartitionsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetPartitionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetPartitionsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetPartitionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetReservation(const QString &reservation_name, const ::hm:slurm:client::OptionalParam<qint64> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetReservation"][_serverIndices.value("slurmV0039GetReservation")].URL()+"/slurm/v0.0.39/reservation/{reservation_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString reservation_namePathParam("{");
        reservation_namePathParam.append("reservation_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "reservation_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"reservation_name"+pathSuffix : pathPrefix;
        fullPath.replace(reservation_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(reservation_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetReservationCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetReservationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_reservations_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetReservationSignal(output);
        Q_EMIT slurmV0039GetReservationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetReservationSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetReservationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetReservationSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetReservationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039GetReservations(const ::hm:slurm:client::OptionalParam<qint64> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0039GetReservations"][_serverIndices.value("slurmV0039GetReservations")].URL()+"/slurm/v0.0.39/reservations");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039GetReservationsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039GetReservationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_reservations_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039GetReservationsSignal(output);
        Q_EMIT slurmV0039GetReservationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039GetReservationsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039GetReservationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039GetReservationsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039GetReservationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039Ping() {
    QString fullPath = QString(_serverConfigs["slurmV0039Ping"][_serverIndices.value("slurmV0039Ping")].URL()+"/slurm/v0.0.39/ping");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039PingCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039PingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_pings output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039PingSignal(output);
        Q_EMIT slurmV0039PingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039PingSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039PingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039PingSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039PingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039SlurmctldGetLicenses() {
    QString fullPath = QString(_serverConfigs["slurmV0039SlurmctldGetLicenses"][_serverIndices.value("slurmV0039SlurmctldGetLicenses")].URL()+"/slurm/v0.0.39/licenses");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039SlurmctldGetLicensesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039SlurmctldGetLicensesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_licenses_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039SlurmctldGetLicensesSignal(output);
        Q_EMIT slurmV0039SlurmctldGetLicensesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039SlurmctldGetLicensesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039SlurmctldGetLicensesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039SlurmctldGetLicensesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039SlurmctldGetLicensesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039SubmitJob(const OAIV0_0_39_job_submission &oaiv0_0_39_job_submission) {
    QString fullPath = QString(_serverConfigs["slurmV0039SubmitJob"][_serverIndices.value("slurmV0039SubmitJob")].URL()+"/slurm/v0.0.39/job/submit");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oaiv0_0_39_job_submission.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039SubmitJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039SubmitJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_job_submission_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039SubmitJobSignal(output);
        Q_EMIT slurmV0039SubmitJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039SubmitJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039SubmitJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039SubmitJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039SubmitJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039UpdateJob(const QString &job_id, const OAIV0_0_39_job_desc_msg &oaiv0_0_39_job_desc_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0039UpdateJob"][_serverIndices.value("slurmV0039UpdateJob")].URL()+"/slurm/v0.0.39/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oaiv0_0_39_job_desc_msg.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039UpdateJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039UpdateJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_39_job_update_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039UpdateJobSignal(output);
        Q_EMIT slurmV0039UpdateJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039UpdateJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039UpdateJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039UpdateJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039UpdateJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0039UpdateNode(const QString &node_name, const OAIV0_0_39_update_node_msg &oaiv0_0_39_update_node_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0039UpdateNode"][_serverIndices.value("slurmV0039UpdateNode")].URL()+"/slurm/v0.0.39/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oaiv0_0_39_update_node_msg.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0039UpdateNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0039UpdateNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0039UpdateNodeSignal(output);
        Q_EMIT slurmV0039UpdateNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0039UpdateNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0039UpdateNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0039UpdateNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0039UpdateNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040DeleteJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<QString> &signal, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040DeleteJob"][_serverIndices.value("slurmV0040DeleteJob")].URL()+"/slurm/v0.0.40/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (signal.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "signal", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("signal")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(signal.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040DeleteJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040DeleteJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040DeleteJobSignal(output);
        Q_EMIT slurmV0040DeleteJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040DeleteJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040DeleteJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040DeleteJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040DeleteJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040DeleteJobs(const ::hm:slurm:client::OptionalParam<OAIV0_0_40_kill_jobs_msg> &oaiv0_0_40_kill_jobs_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0040DeleteJobs"][_serverIndices.value("slurmV0040DeleteJobs")].URL()+"/slurm/v0.0.40/jobs/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");

    if (oaiv0_0_40_kill_jobs_msg.hasValue()){

        
        QByteArray output = oaiv0_0_40_kill_jobs_msg.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040DeleteJobsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040DeleteJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_kill_jobs_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040DeleteJobsSignal(output);
        Q_EMIT slurmV0040DeleteJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040DeleteJobsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040DeleteJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040DeleteJobsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040DeleteJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040DeleteNode(const QString &node_name) {
    QString fullPath = QString(_serverConfigs["slurmV0040DeleteNode"][_serverIndices.value("slurmV0040DeleteNode")].URL()+"/slurm/v0.0.40/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040DeleteNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040DeleteNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040DeleteNodeSignal(output);
        Q_EMIT slurmV0040DeleteNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040DeleteNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040DeleteNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040DeleteNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040DeleteNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetDiag() {
    QString fullPath = QString(_serverConfigs["slurmV0040GetDiag"][_serverIndices.value("slurmV0040GetDiag")].URL()+"/slurm/v0.0.40/diag/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetDiagCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetDiagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_diag_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetDiagSignal(output);
        Q_EMIT slurmV0040GetDiagSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetDiagSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetDiagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetDiagSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetDiagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetJob"][_serverIndices.value("slurmV0040GetJob")].URL()+"/slurm/v0.0.40/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_job_info_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetJobSignal(output);
        Q_EMIT slurmV0040GetJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetJobs(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetJobs"][_serverIndices.value("slurmV0040GetJobs")].URL()+"/slurm/v0.0.40/jobs/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetJobsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_job_info_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetJobsSignal(output);
        Q_EMIT slurmV0040GetJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetJobsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetJobsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetJobsState(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetJobsState"][_serverIndices.value("slurmV0040GetJobsState")].URL()+"/slurm/v0.0.40/jobs/state/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetJobsStateCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetJobsStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_job_info_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetJobsStateSignal(output);
        Q_EMIT slurmV0040GetJobsStateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetJobsStateSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetJobsStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetJobsStateSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetJobsStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetLicenses() {
    QString fullPath = QString(_serverConfigs["slurmV0040GetLicenses"][_serverIndices.value("slurmV0040GetLicenses")].URL()+"/slurm/v0.0.40/licenses/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetLicensesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetLicensesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_licenses_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetLicensesSignal(output);
        Q_EMIT slurmV0040GetLicensesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetLicensesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetLicensesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetLicensesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetLicensesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetNode(const QString &node_name, const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetNode"][_serverIndices.value("slurmV0040GetNode")].URL()+"/slurm/v0.0.40/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_nodes_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetNodeSignal(output);
        Q_EMIT slurmV0040GetNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetNodes(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetNodes"][_serverIndices.value("slurmV0040GetNodes")].URL()+"/slurm/v0.0.40/nodes/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetNodesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetNodesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_nodes_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetNodesSignal(output);
        Q_EMIT slurmV0040GetNodesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetNodesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetNodesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetNodesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetNodesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetPartition(const QString &partition_name, const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetPartition"][_serverIndices.value("slurmV0040GetPartition")].URL()+"/slurm/v0.0.40/partition/{partition_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString partition_namePathParam("{");
        partition_namePathParam.append("partition_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "partition_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"partition_name"+pathSuffix : pathPrefix;
        fullPath.replace(partition_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetPartitionCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetPartitionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_partition_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetPartitionSignal(output);
        Q_EMIT slurmV0040GetPartitionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetPartitionSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetPartitionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetPartitionSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetPartitionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetPartitions(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetPartitions"][_serverIndices.value("slurmV0040GetPartitions")].URL()+"/slurm/v0.0.40/partitions/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetPartitionsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetPartitionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_partition_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetPartitionsSignal(output);
        Q_EMIT slurmV0040GetPartitionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetPartitionsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetPartitionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetPartitionsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetPartitionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetPing() {
    QString fullPath = QString(_serverConfigs["slurmV0040GetPing"][_serverIndices.value("slurmV0040GetPing")].URL()+"/slurm/v0.0.40/ping/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetPingCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetPingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_ping_array_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetPingSignal(output);
        Q_EMIT slurmV0040GetPingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetPingSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetPingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetPingSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetPingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetReconfigure() {
    QString fullPath = QString(_serverConfigs["slurmV0040GetReconfigure"][_serverIndices.value("slurmV0040GetReconfigure")].URL()+"/slurm/v0.0.40/reconfigure/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetReconfigureCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetReconfigureCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetReconfigureSignal(output);
        Q_EMIT slurmV0040GetReconfigureSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetReconfigureSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetReconfigureSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetReconfigureSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetReconfigureSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetReservation(const QString &reservation_name, const ::hm:slurm:client::OptionalParam<QString> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetReservation"][_serverIndices.value("slurmV0040GetReservation")].URL()+"/slurm/v0.0.40/reservation/{reservation_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString reservation_namePathParam("{");
        reservation_namePathParam.append("reservation_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "reservation_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"reservation_name"+pathSuffix : pathPrefix;
        fullPath.replace(reservation_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(reservation_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetReservationCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetReservationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_reservation_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetReservationSignal(output);
        Q_EMIT slurmV0040GetReservationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetReservationSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetReservationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetReservationSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetReservationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetReservations(const ::hm:slurm:client::OptionalParam<QString> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetReservations"][_serverIndices.value("slurmV0040GetReservations")].URL()+"/slurm/v0.0.40/reservations/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetReservationsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetReservationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_reservation_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetReservationsSignal(output);
        Q_EMIT slurmV0040GetReservationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetReservationsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetReservationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetReservationsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetReservationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040GetShares(const ::hm:slurm:client::OptionalParam<QString> &accounts, const ::hm:slurm:client::OptionalParam<QString> &users) {
    QString fullPath = QString(_serverConfigs["slurmV0040GetShares"][_serverIndices.value("slurmV0040GetShares")].URL()+"/slurm/v0.0.40/shares");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (accounts.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "accounts", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("accounts")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(accounts.stringValue())));
    }
    if (users.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "users", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("users")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(users.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040GetSharesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040GetSharesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_shares_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040GetSharesSignal(output);
        Q_EMIT slurmV0040GetSharesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040GetSharesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040GetSharesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040GetSharesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040GetSharesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040PostJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<OAIV0_0_40_job_desc_msg> &oaiv0_0_40_job_desc_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0040PostJob"][_serverIndices.value("slurmV0040PostJob")].URL()+"/slurm/v0.0.40/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_40_job_desc_msg.hasValue()){

        
        QByteArray output = oaiv0_0_40_job_desc_msg.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040PostJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040PostJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_job_post_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040PostJobSignal(output);
        Q_EMIT slurmV0040PostJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040PostJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040PostJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040PostJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040PostJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040PostJobSubmit(const ::hm:slurm:client::OptionalParam<OAIV0_0_40_job_submit_req> &oaiv0_0_40_job_submit_req) {
    QString fullPath = QString(_serverConfigs["slurmV0040PostJobSubmit"][_serverIndices.value("slurmV0040PostJobSubmit")].URL()+"/slurm/v0.0.40/job/submit");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_40_job_submit_req.hasValue()){

        
        QByteArray output = oaiv0_0_40_job_submit_req.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040PostJobSubmitCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040PostJobSubmitCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_job_submit_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040PostJobSubmitSignal(output);
        Q_EMIT slurmV0040PostJobSubmitSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040PostJobSubmitSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040PostJobSubmitSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040PostJobSubmitSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040PostJobSubmitSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0040PostNode(const QString &node_name, const ::hm:slurm:client::OptionalParam<OAIV0_0_40_update_node_msg> &oaiv0_0_40_update_node_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0040PostNode"][_serverIndices.value("slurmV0040PostNode")].URL()+"/slurm/v0.0.40/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_40_update_node_msg.hasValue()){

        
        QByteArray output = oaiv0_0_40_update_node_msg.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0040PostNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0040PostNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_40_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0040PostNodeSignal(output);
        Q_EMIT slurmV0040PostNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0040PostNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0040PostNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0040PostNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0040PostNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041DeleteJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<QString> &signal, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041DeleteJob"][_serverIndices.value("slurmV0041DeleteJob")].URL()+"/slurm/v0.0.41/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (signal.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "signal", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("signal")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(signal.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041DeleteJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041DeleteJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041DeleteJobSignal(output);
        Q_EMIT slurmV0041DeleteJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041DeleteJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041DeleteJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041DeleteJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041DeleteJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041DeleteJobs(const ::hm:slurm:client::OptionalParam<OAIV0_0_41_kill_jobs_msg> &oaiv0_0_41_kill_jobs_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0041DeleteJobs"][_serverIndices.value("slurmV0041DeleteJobs")].URL()+"/slurm/v0.0.41/jobs/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");

    if (oaiv0_0_41_kill_jobs_msg.hasValue()){

        
        QByteArray output = oaiv0_0_41_kill_jobs_msg.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041DeleteJobsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041DeleteJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_kill_jobs_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041DeleteJobsSignal(output);
        Q_EMIT slurmV0041DeleteJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041DeleteJobsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041DeleteJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041DeleteJobsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041DeleteJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041DeleteNode(const QString &node_name) {
    QString fullPath = QString(_serverConfigs["slurmV0041DeleteNode"][_serverIndices.value("slurmV0041DeleteNode")].URL()+"/slurm/v0.0.41/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041DeleteNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041DeleteNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041DeleteNodeSignal(output);
        Q_EMIT slurmV0041DeleteNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041DeleteNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041DeleteNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041DeleteNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041DeleteNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetDiag() {
    QString fullPath = QString(_serverConfigs["slurmV0041GetDiag"][_serverIndices.value("slurmV0041GetDiag")].URL()+"/slurm/v0.0.41/diag/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetDiagCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetDiagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_diag_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetDiagSignal(output);
        Q_EMIT slurmV0041GetDiagSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetDiagSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetDiagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetDiagSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetDiagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetJob"][_serverIndices.value("slurmV0041GetJob")].URL()+"/slurm/v0.0.41/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_job_info_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetJobSignal(output);
        Q_EMIT slurmV0041GetJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetJobs(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetJobs"][_serverIndices.value("slurmV0041GetJobs")].URL()+"/slurm/v0.0.41/jobs/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetJobsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_job_info_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetJobsSignal(output);
        Q_EMIT slurmV0041GetJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetJobsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetJobsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetJobsState(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetJobsState"][_serverIndices.value("slurmV0041GetJobsState")].URL()+"/slurm/v0.0.41/jobs/state/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetJobsStateCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetJobsStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_job_info_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetJobsStateSignal(output);
        Q_EMIT slurmV0041GetJobsStateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetJobsStateSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetJobsStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetJobsStateSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetJobsStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetLicenses() {
    QString fullPath = QString(_serverConfigs["slurmV0041GetLicenses"][_serverIndices.value("slurmV0041GetLicenses")].URL()+"/slurm/v0.0.41/licenses/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetLicensesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetLicensesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_licenses_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetLicensesSignal(output);
        Q_EMIT slurmV0041GetLicensesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetLicensesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetLicensesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetLicensesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetLicensesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetNode(const QString &node_name, const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetNode"][_serverIndices.value("slurmV0041GetNode")].URL()+"/slurm/v0.0.41/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_nodes_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetNodeSignal(output);
        Q_EMIT slurmV0041GetNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetNodes(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetNodes"][_serverIndices.value("slurmV0041GetNodes")].URL()+"/slurm/v0.0.41/nodes/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetNodesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetNodesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_nodes_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetNodesSignal(output);
        Q_EMIT slurmV0041GetNodesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetNodesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetNodesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetNodesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetNodesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetPartition(const QString &partition_name, const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetPartition"][_serverIndices.value("slurmV0041GetPartition")].URL()+"/slurm/v0.0.41/partition/{partition_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString partition_namePathParam("{");
        partition_namePathParam.append("partition_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "partition_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"partition_name"+pathSuffix : pathPrefix;
        fullPath.replace(partition_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetPartitionCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetPartitionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_partition_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetPartitionSignal(output);
        Q_EMIT slurmV0041GetPartitionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetPartitionSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetPartitionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetPartitionSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetPartitionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetPartitions(const ::hm:slurm:client::OptionalParam<QString> &update_time, const ::hm:slurm:client::OptionalParam<QString> &flags) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetPartitions"][_serverIndices.value("slurmV0041GetPartitions")].URL()+"/slurm/v0.0.41/partitions/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    if (flags.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "flags", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("flags")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(flags.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetPartitionsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetPartitionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_partition_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetPartitionsSignal(output);
        Q_EMIT slurmV0041GetPartitionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetPartitionsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetPartitionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetPartitionsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetPartitionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetPing() {
    QString fullPath = QString(_serverConfigs["slurmV0041GetPing"][_serverIndices.value("slurmV0041GetPing")].URL()+"/slurm/v0.0.41/ping/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetPingCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetPingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_ping_array_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetPingSignal(output);
        Q_EMIT slurmV0041GetPingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetPingSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetPingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetPingSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetPingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetReconfigure() {
    QString fullPath = QString(_serverConfigs["slurmV0041GetReconfigure"][_serverIndices.value("slurmV0041GetReconfigure")].URL()+"/slurm/v0.0.41/reconfigure/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetReconfigureCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetReconfigureCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetReconfigureSignal(output);
        Q_EMIT slurmV0041GetReconfigureSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetReconfigureSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetReconfigureSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetReconfigureSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetReconfigureSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetReservation(const QString &reservation_name, const ::hm:slurm:client::OptionalParam<QString> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetReservation"][_serverIndices.value("slurmV0041GetReservation")].URL()+"/slurm/v0.0.41/reservation/{reservation_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString reservation_namePathParam("{");
        reservation_namePathParam.append("reservation_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "reservation_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"reservation_name"+pathSuffix : pathPrefix;
        fullPath.replace(reservation_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(reservation_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetReservationCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetReservationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_reservation_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetReservationSignal(output);
        Q_EMIT slurmV0041GetReservationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetReservationSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetReservationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetReservationSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetReservationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetReservations(const ::hm:slurm:client::OptionalParam<QString> &update_time) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetReservations"][_serverIndices.value("slurmV0041GetReservations")].URL()+"/slurm/v0.0.41/reservations/");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (update_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "update_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("update_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(update_time.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetReservationsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetReservationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_reservation_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetReservationsSignal(output);
        Q_EMIT slurmV0041GetReservationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetReservationsSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetReservationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetReservationsSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetReservationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041GetShares(const ::hm:slurm:client::OptionalParam<QString> &accounts, const ::hm:slurm:client::OptionalParam<QString> &users) {
    QString fullPath = QString(_serverConfigs["slurmV0041GetShares"][_serverIndices.value("slurmV0041GetShares")].URL()+"/slurm/v0.0.41/shares");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (accounts.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "accounts", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("accounts")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(accounts.stringValue())));
    }
    if (users.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "users", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("users")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(users.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041GetSharesCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041GetSharesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_shares_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041GetSharesSignal(output);
        Q_EMIT slurmV0041GetSharesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041GetSharesSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041GetSharesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041GetSharesSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041GetSharesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041PostJob(const QString &job_id, const ::hm:slurm:client::OptionalParam<OAIV0_0_41_job_desc_msg> &oaiv0_0_41_job_desc_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0041PostJob"][_serverIndices.value("slurmV0041PostJob")].URL()+"/slurm/v0.0.41/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_41_job_desc_msg.hasValue()){

        
        QByteArray output = oaiv0_0_41_job_desc_msg.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041PostJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041PostJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_job_post_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041PostJobSignal(output);
        Q_EMIT slurmV0041PostJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041PostJobSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041PostJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041PostJobSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041PostJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041PostJobAllocate(const ::hm:slurm:client::OptionalParam<OAIV0_0_41_job_alloc_req> &oaiv0_0_41_job_alloc_req) {
    QString fullPath = QString(_serverConfigs["slurmV0041PostJobAllocate"][_serverIndices.value("slurmV0041PostJobAllocate")].URL()+"/slurm/v0.0.41/job/allocate");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_41_job_alloc_req.hasValue()){

        
        QByteArray output = oaiv0_0_41_job_alloc_req.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041PostJobAllocateCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041PostJobAllocateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_job_alloc_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041PostJobAllocateSignal(output);
        Q_EMIT slurmV0041PostJobAllocateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041PostJobAllocateSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041PostJobAllocateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041PostJobAllocateSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041PostJobAllocateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041PostJobSubmit(const ::hm:slurm:client::OptionalParam<OAIV0_0_41_job_submit_req> &oaiv0_0_41_job_submit_req) {
    QString fullPath = QString(_serverConfigs["slurmV0041PostJobSubmit"][_serverIndices.value("slurmV0041PostJobSubmit")].URL()+"/slurm/v0.0.41/job/submit");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_41_job_submit_req.hasValue()){

        
        QByteArray output = oaiv0_0_41_job_submit_req.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041PostJobSubmitCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041PostJobSubmitCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_job_submit_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041PostJobSubmitSignal(output);
        Q_EMIT slurmV0041PostJobSubmitSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041PostJobSubmitSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041PostJobSubmitSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041PostJobSubmitSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041PostJobSubmitSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmV0041PostNode(const QString &node_name, const ::hm:slurm:client::OptionalParam<OAIV0_0_41_update_node_msg> &oaiv0_0_41_update_node_msg) {
    QString fullPath = QString(_serverConfigs["slurmV0041PostNode"][_serverIndices.value("slurmV0041PostNode")].URL()+"/slurm/v0.0.41/node/{node_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString node_namePathParam("{");
        node_namePathParam.append("node_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_name"+pathSuffix : pathPrefix;
        fullPath.replace(node_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiv0_0_41_update_node_msg.hasValue()){

        
        QByteArray output = oaiv0_0_41_update_node_msg.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmV0041PostNodeCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmV0041PostNodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIV0_0_41_openapi_resp output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmV0041PostNodeSignal(output);
        Q_EMIT slurmV0041PostNodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmV0041PostNodeSignalE(output, error_type, error_str);
        Q_EMIT slurmV0041PostNodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmV0041PostNodeSignalError(output, error_type, error_str);
        Q_EMIT slurmV0041PostNodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039AddClusters(const OAIDbv0_0_39_clusters_info &oai_dbv0_0_39_clusters_info) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039AddClusters"][_serverIndices.value("slurmdbV0039AddClusters")].URL()+"/slurmdb/v0.0.39/clusters");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dbv0_0_39_clusters_info.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039AddClustersCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039AddClustersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039AddClustersSignal(output);
        Q_EMIT slurmdbV0039AddClustersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039AddClustersSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039AddClustersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039AddClustersSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039AddClustersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039AddWckeys(const ::hm:slurm:client::OptionalParam<OAIDbv0_0_39_wckey_info> &oai_dbv0_0_39_wckey_info) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039AddWckeys"][_serverIndices.value("slurmdbV0039AddWckeys")].URL()+"/slurmdb/v0.0.39/wckeys");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_dbv0_0_39_wckey_info.hasValue()){

        
        QByteArray output = oai_dbv0_0_39_wckey_info.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039AddWckeysCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039AddWckeysCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039AddWckeysSignal(output);
        Q_EMIT slurmdbV0039AddWckeysSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039AddWckeysSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039AddWckeysSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039AddWckeysSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039AddWckeysSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteAccount(const QString &account_name) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteAccount"][_serverIndices.value("slurmdbV0039DeleteAccount")].URL()+"/slurmdb/v0.0.39/account/{account_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString account_namePathParam("{");
        account_namePathParam.append("account_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "account_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"account_name"+pathSuffix : pathPrefix;
        fullPath.replace(account_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteAccountCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteAccountCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteAccountSignal(output);
        Q_EMIT slurmdbV0039DeleteAccountSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteAccountSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteAccountSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteAccountSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteAccountSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteAssociation(const ::hm:slurm:client::OptionalParam<QString> &cluster, const ::hm:slurm:client::OptionalParam<QString> &account, const ::hm:slurm:client::OptionalParam<QString> &user, const ::hm:slurm:client::OptionalParam<QString> &partition) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteAssociation"][_serverIndices.value("slurmdbV0039DeleteAssociation")].URL()+"/slurmdb/v0.0.39/association");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cluster.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cluster", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cluster")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster.stringValue())));
    }
    if (account.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "account", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("account")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account.stringValue())));
    }
    if (user.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(user.stringValue())));
    }
    if (partition.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "partition", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("partition")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteAssociationCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteAssociationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_response_associations_delete output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteAssociationSignal(output);
        Q_EMIT slurmdbV0039DeleteAssociationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteAssociationSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteAssociationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteAssociationSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteAssociationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteAssociations(const ::hm:slurm:client::OptionalParam<QString> &cluster, const ::hm:slurm:client::OptionalParam<QString> &account, const ::hm:slurm:client::OptionalParam<QString> &user, const ::hm:slurm:client::OptionalParam<QString> &partition) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteAssociations"][_serverIndices.value("slurmdbV0039DeleteAssociations")].URL()+"/slurmdb/v0.0.39/associations");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cluster.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cluster", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cluster")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster.stringValue())));
    }
    if (account.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "account", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("account")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account.stringValue())));
    }
    if (user.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(user.stringValue())));
    }
    if (partition.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "partition", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("partition")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteAssociationsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteAssociationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_response_associations_delete output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteAssociationsSignal(output);
        Q_EMIT slurmdbV0039DeleteAssociationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteAssociationsSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteAssociationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteAssociationsSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteAssociationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteCluster(const QString &cluster_name) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteCluster"][_serverIndices.value("slurmdbV0039DeleteCluster")].URL()+"/slurmdb/v0.0.39/cluster/{cluster_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString cluster_namePathParam("{");
        cluster_namePathParam.append("cluster_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "cluster_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"cluster_name"+pathSuffix : pathPrefix;
        fullPath.replace(cluster_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteClusterCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteClusterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteClusterSignal(output);
        Q_EMIT slurmdbV0039DeleteClusterSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteClusterSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteClusterSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteClusterSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteClusterSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteQos(const QString &qos_name) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteQos"][_serverIndices.value("slurmdbV0039DeleteQos")].URL()+"/slurmdb/v0.0.39/qos/{qos_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString qos_namePathParam("{");
        qos_namePathParam.append("qos_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "qos_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"qos_name"+pathSuffix : pathPrefix;
        fullPath.replace(qos_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(qos_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteQosCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteQosCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteQosSignal(output);
        Q_EMIT slurmdbV0039DeleteQosSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteQosSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteQosSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteQosSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteQosSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteUser(const QString &user_name) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteUser"][_serverIndices.value("slurmdbV0039DeleteUser")].URL()+"/slurmdb/v0.0.39/user/{user_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString user_namePathParam("{");
        user_namePathParam.append("user_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_name"+pathSuffix : pathPrefix;
        fullPath.replace(user_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(user_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteUserCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteUserSignal(output);
        Q_EMIT slurmdbV0039DeleteUserSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteUserSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteUserSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039DeleteWckey(const QString &wckey) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039DeleteWckey"][_serverIndices.value("slurmdbV0039DeleteWckey")].URL()+"/slurmdb/v0.0.39/wckey/{wckey}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString wckeyPathParam("{");
        wckeyPathParam.append("wckey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "wckey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"wckey"+pathSuffix : pathPrefix;
        fullPath.replace(wckeyPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(wckey)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DeleteWckeyCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DeleteWckeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DeleteWckeySignal(output);
        Q_EMIT slurmdbV0039DeleteWckeySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DeleteWckeySignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteWckeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DeleteWckeySignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DeleteWckeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039Diag() {
    QString fullPath = QString(_serverConfigs["slurmdbV0039Diag"][_serverIndices.value("slurmdbV0039Diag")].URL()+"/slurmdb/v0.0.39/diag");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039DiagCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039DiagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_diag output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039DiagSignal(output);
        Q_EMIT slurmdbV0039DiagSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039DiagSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039DiagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039DiagSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039DiagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetAccount(const QString &account_name, const ::hm:slurm:client::OptionalParam<QString> &with_deleted) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetAccount"][_serverIndices.value("slurmdbV0039GetAccount")].URL()+"/slurmdb/v0.0.39/account/{account_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString account_namePathParam("{");
        account_namePathParam.append("account_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "account_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"account_name"+pathSuffix : pathPrefix;
        fullPath.replace(account_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_deleted", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(with_deleted.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetAccountCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetAccountCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_account_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetAccountSignal(output);
        Q_EMIT slurmdbV0039GetAccountSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetAccountSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAccountSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetAccountSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAccountSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetAccounts(const ::hm:slurm:client::OptionalParam<QString> &with_deleted) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetAccounts"][_serverIndices.value("slurmdbV0039GetAccounts")].URL()+"/slurmdb/v0.0.39/accounts");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_deleted", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(with_deleted.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetAccountsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetAccountsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_account_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetAccountsSignal(output);
        Q_EMIT slurmdbV0039GetAccountsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetAccountsSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAccountsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetAccountsSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAccountsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetAssociation(const ::hm:slurm:client::OptionalParam<QString> &cluster, const ::hm:slurm:client::OptionalParam<QString> &account, const ::hm:slurm:client::OptionalParam<QString> &user, const ::hm:slurm:client::OptionalParam<QString> &partition) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetAssociation"][_serverIndices.value("slurmdbV0039GetAssociation")].URL()+"/slurmdb/v0.0.39/association");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cluster.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cluster", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cluster")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster.stringValue())));
    }
    if (account.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "account", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("account")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account.stringValue())));
    }
    if (user.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(user.stringValue())));
    }
    if (partition.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "partition", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("partition")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetAssociationCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetAssociationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_associations_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetAssociationSignal(output);
        Q_EMIT slurmdbV0039GetAssociationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetAssociationSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAssociationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetAssociationSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAssociationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetAssociations(const ::hm:slurm:client::OptionalParam<QString> &cluster, const ::hm:slurm:client::OptionalParam<QString> &account, const ::hm:slurm:client::OptionalParam<QString> &user, const ::hm:slurm:client::OptionalParam<QString> &partition) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetAssociations"][_serverIndices.value("slurmdbV0039GetAssociations")].URL()+"/slurmdb/v0.0.39/associations");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cluster.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cluster", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cluster")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster.stringValue())));
    }
    if (account.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "account", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("account")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account.stringValue())));
    }
    if (user.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(user.stringValue())));
    }
    if (partition.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "partition", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("partition")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetAssociationsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetAssociationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_associations_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetAssociationsSignal(output);
        Q_EMIT slurmdbV0039GetAssociationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetAssociationsSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAssociationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetAssociationsSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetAssociationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetCluster(const QString &cluster_name) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetCluster"][_serverIndices.value("slurmdbV0039GetCluster")].URL()+"/slurmdb/v0.0.39/cluster/{cluster_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString cluster_namePathParam("{");
        cluster_namePathParam.append("cluster_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "cluster_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"cluster_name"+pathSuffix : pathPrefix;
        fullPath.replace(cluster_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetClusterCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetClusterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_clusters_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetClusterSignal(output);
        Q_EMIT slurmdbV0039GetClusterSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetClusterSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetClusterSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetClusterSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetClusterSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetClusters() {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetClusters"][_serverIndices.value("slurmdbV0039GetClusters")].URL()+"/slurmdb/v0.0.39/clusters");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetClustersCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetClustersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_clusters_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetClustersSignal(output);
        Q_EMIT slurmdbV0039GetClustersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetClustersSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetClustersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetClustersSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetClustersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetConfig() {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetConfig"][_serverIndices.value("slurmdbV0039GetConfig")].URL()+"/slurmdb/v0.0.39/config");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetConfigCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_config_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetConfigSignal(output);
        Q_EMIT slurmdbV0039GetConfigSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetConfigSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetConfigSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetConfigSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetConfigSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetJob(const QString &job_id) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetJob"][_serverIndices.value("slurmdbV0039GetJob")].URL()+"/slurmdb/v0.0.39/job/{job_id}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString job_idPathParam("{");
        job_idPathParam.append("job_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "job_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"job_id"+pathSuffix : pathPrefix;
        fullPath.replace(job_idPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetJobCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_job_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetJobSignal(output);
        Q_EMIT slurmdbV0039GetJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetJobSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetJobSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetJobs(const ::hm:slurm:client::OptionalParam<QString> &users, const ::hm:slurm:client::OptionalParam<QString> &submit_time, const ::hm:slurm:client::OptionalParam<QString> &start_time, const ::hm:slurm:client::OptionalParam<QString> &end_time, const ::hm:slurm:client::OptionalParam<QString> &account, const ::hm:slurm:client::OptionalParam<QString> &association, const ::hm:slurm:client::OptionalParam<QString> &cluster, const ::hm:slurm:client::OptionalParam<QString> &constraints, const ::hm:slurm:client::OptionalParam<QString> &cpus_max, const ::hm:slurm:client::OptionalParam<QString> &cpus_min, const ::hm:slurm:client::OptionalParam<QString> &skip_steps, const ::hm:slurm:client::OptionalParam<QString> &disable_wait_for_result, const ::hm:slurm:client::OptionalParam<QString> &exit_code, const ::hm:slurm:client::OptionalParam<QString> &format, const ::hm:slurm:client::OptionalParam<QString> &group, const ::hm:slurm:client::OptionalParam<QString> &job_name, const ::hm:slurm:client::OptionalParam<QString> &nodes_max, const ::hm:slurm:client::OptionalParam<QString> &nodes_min, const ::hm:slurm:client::OptionalParam<QString> &partition, const ::hm:slurm:client::OptionalParam<QString> &qos, const ::hm:slurm:client::OptionalParam<QString> &reason, const ::hm:slurm:client::OptionalParam<QString> &reservation, const ::hm:slurm:client::OptionalParam<QString> &state, const ::hm:slurm:client::OptionalParam<QString> &step, const ::hm:slurm:client::OptionalParam<QString> &node, const ::hm:slurm:client::OptionalParam<QString> &wckey) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetJobs"][_serverIndices.value("slurmdbV0039GetJobs")].URL()+"/slurmdb/v0.0.39/jobs");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (users.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "users", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("users")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(users.stringValue())));
    }
    if (submit_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "submit_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("submit_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(submit_time.stringValue())));
    }
    if (start_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "start_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("start_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(start_time.stringValue())));
    }
    if (end_time.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "end_time", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("end_time")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(end_time.stringValue())));
    }
    if (account.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "account", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("account")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(account.stringValue())));
    }
    if (association.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "association", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("association")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(association.stringValue())));
    }
    if (cluster.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cluster", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cluster")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cluster.stringValue())));
    }
    if (constraints.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "constraints", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("constraints")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(constraints.stringValue())));
    }
    if (cpus_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cpus_max", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cpus_max")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cpus_max.stringValue())));
    }
    if (cpus_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cpus_min", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cpus_min")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(cpus_min.stringValue())));
    }
    if (skip_steps.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "skip_steps", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("skip_steps")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(skip_steps.stringValue())));
    }
    if (disable_wait_for_result.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "disable_wait_for_result", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("disable_wait_for_result")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(disable_wait_for_result.stringValue())));
    }
    if (exit_code.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exit_code", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exit_code")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(exit_code.stringValue())));
    }
    if (format.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "format", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("format")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(format.stringValue())));
    }
    if (group.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "group", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("group")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(group.stringValue())));
    }
    if (job_name.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "job_name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("job_name")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(job_name.stringValue())));
    }
    if (nodes_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "nodes_max", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("nodes_max")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(nodes_max.stringValue())));
    }
    if (nodes_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "nodes_min", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("nodes_min")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(nodes_min.stringValue())));
    }
    if (partition.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "partition", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("partition")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(partition.stringValue())));
    }
    if (qos.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "qos", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("qos")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(qos.stringValue())));
    }
    if (reason.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "reason", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("reason")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(reason.stringValue())));
    }
    if (reservation.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "reservation", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("reservation")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(reservation.stringValue())));
    }
    if (state.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "state", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("state")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(state.stringValue())));
    }
    if (step.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "step", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("step")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(step.stringValue())));
    }
    if (node.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "node", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("node")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(node.stringValue())));
    }
    if (wckey.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "wckey", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("wckey")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(wckey.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetJobsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_job_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetJobsSignal(output);
        Q_EMIT slurmdbV0039GetJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetJobsSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetJobsSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetQos(const ::hm:slurm:client::OptionalParam<QString> &with_deleted) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetQos"][_serverIndices.value("slurmdbV0039GetQos")].URL()+"/slurmdb/v0.0.39/qos");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_deleted", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(with_deleted.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetQosCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetQosCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_qos_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetQosSignal(output);
        Q_EMIT slurmdbV0039GetQosSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetQosSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetQosSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetQosSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetQosSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetSingleQos(const QString &qos_name, const ::hm:slurm:client::OptionalParam<QString> &with_deleted) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetSingleQos"][_serverIndices.value("slurmdbV0039GetSingleQos")].URL()+"/slurmdb/v0.0.39/qos/{qos_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString qos_namePathParam("{");
        qos_namePathParam.append("qos_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "qos_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"qos_name"+pathSuffix : pathPrefix;
        fullPath.replace(qos_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(qos_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_deleted", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(with_deleted.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetSingleQosCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetSingleQosCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_qos_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetSingleQosSignal(output);
        Q_EMIT slurmdbV0039GetSingleQosSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetSingleQosSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetSingleQosSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetSingleQosSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetSingleQosSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetTres() {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetTres"][_serverIndices.value("slurmdbV0039GetTres")].URL()+"/slurmdb/v0.0.39/tres");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetTresCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetTresCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_tres_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetTresSignal(output);
        Q_EMIT slurmdbV0039GetTresSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetTresSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetTresSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetTresSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetTresSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetUser(const QString &user_name, const ::hm:slurm:client::OptionalParam<QString> &with_deleted) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetUser"][_serverIndices.value("slurmdbV0039GetUser")].URL()+"/slurmdb/v0.0.39/user/{user_name}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString user_namePathParam("{");
        user_namePathParam.append("user_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_name"+pathSuffix : pathPrefix;
        fullPath.replace(user_namePathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(user_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_deleted", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(with_deleted.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetUserCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_user_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetUserSignal(output);
        Q_EMIT slurmdbV0039GetUserSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetUserSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetUserSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetUsers(const ::hm:slurm:client::OptionalParam<QString> &with_deleted) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetUsers"][_serverIndices.value("slurmdbV0039GetUsers")].URL()+"/slurmdb/v0.0.39/users");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_deleted", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(with_deleted.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetUsersCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetUsersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_user_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetUsersSignal(output);
        Q_EMIT slurmdbV0039GetUsersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetUsersSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetUsersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetUsersSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetUsersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetWckey(const QString &wckey) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetWckey"][_serverIndices.value("slurmdbV0039GetWckey")].URL()+"/slurmdb/v0.0.39/wckey/{wckey}");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    
    {
        QString wckeyPathParam("{");
        wckeyPathParam.append("wckey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "wckey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"wckey"+pathSuffix : pathPrefix;
        fullPath.replace(wckeyPathParam, paramString+QUrl::toPercentEncoding(::hm:slurm:client::toStringValue(wckey)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetWckeyCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetWckeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_wckey_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetWckeySignal(output);
        Q_EMIT slurmdbV0039GetWckeySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetWckeySignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetWckeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetWckeySignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetWckeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039GetWckeys() {
    QString fullPath = QString(_serverConfigs["slurmdbV0039GetWckeys"][_serverIndices.value("slurmdbV0039GetWckeys")].URL()+"/slurmdb/v0.0.39/wckeys");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039GetWckeysCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039GetWckeysCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDbv0_0_39_wckey_info output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039GetWckeysSignal(output);
        Q_EMIT slurmdbV0039GetWckeysSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039GetWckeysSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetWckeysSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039GetWckeysSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039GetWckeysSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039SetConfig(const ::hm:slurm:client::OptionalParam<OAIDbv0_0_39_set_config> &oai_dbv0_0_39_set_config) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039SetConfig"][_serverIndices.value("slurmdbV0039SetConfig")].URL()+"/slurmdb/v0.0.39/config");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_dbv0_0_39_set_config.hasValue()){

        
        QByteArray output = oai_dbv0_0_39_set_config.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039SetConfigCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039SetConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039SetConfigSignal(output);
        Q_EMIT slurmdbV0039SetConfigSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039SetConfigSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039SetConfigSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039SetConfigSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039SetConfigSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039UpdateAccounts(const OAIDbv0_0_39_account_info &oai_dbv0_0_39_account_info) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039UpdateAccounts"][_serverIndices.value("slurmdbV0039UpdateAccounts")].URL()+"/slurmdb/v0.0.39/accounts");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dbv0_0_39_account_info.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039UpdateAccountsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039UpdateAccountsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039UpdateAccountsSignal(output);
        Q_EMIT slurmdbV0039UpdateAccountsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039UpdateAccountsSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateAccountsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039UpdateAccountsSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateAccountsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039UpdateAssociations(const OAIDbv0_0_39_associations_info &oai_dbv0_0_39_associations_info) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039UpdateAssociations"][_serverIndices.value("slurmdbV0039UpdateAssociations")].URL()+"/slurmdb/v0.0.39/associations");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dbv0_0_39_associations_info.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039UpdateAssociationsCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039UpdateAssociationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039UpdateAssociationsSignal(output);
        Q_EMIT slurmdbV0039UpdateAssociationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039UpdateAssociationsSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateAssociationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039UpdateAssociationsSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateAssociationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039UpdateQos(const OAIDbv0_0_39_update_qos &oai_dbv0_0_39_update_qos) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039UpdateQos"][_serverIndices.value("slurmdbV0039UpdateQos")].URL()+"/slurmdb/v0.0.39/qos");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dbv0_0_39_update_qos.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039UpdateQosCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039UpdateQosCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039UpdateQosSignal(output);
        Q_EMIT slurmdbV0039UpdateQosSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039UpdateQosSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateQosSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039UpdateQosSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateQosSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039UpdateTres(const OAIDbv0_0_39_tres_update &oai_dbv0_0_39_tres_update) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039UpdateTres"][_serverIndices.value("slurmdbV0039UpdateTres")].URL()+"/slurmdb/v0.0.39/tres");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dbv0_0_39_tres_update.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039UpdateTresCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039UpdateTresCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039UpdateTresSignal(output);
        Q_EMIT slurmdbV0039UpdateTresSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039UpdateTresSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateTresSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039UpdateTresSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateTresSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::slurmdbV0039UpdateUsers(const OAIDbv0_0_39_update_users &oai_dbv0_0_39_update_users) {
    QString fullPath = QString(_serverConfigs["slurmdbV0039UpdateUsers"][_serverIndices.value("slurmdbV0039UpdateUsers")].URL()+"/slurmdb/v0.0.39/users");
    
    if (_apiKeys.contains("user")) {
        addHeaders("user",_apiKeys.find("user").value());
    }
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    if (_apiKeys.contains("token")) {
        addHeaders("token",_apiKeys.find("token").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dbv0_0_39_update_users.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISlurmApi::slurmdbV0039UpdateUsersCallback);
    connect(this, &OAISlurmApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISlurmApi::slurmdbV0039UpdateUsersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT slurmdbV0039UpdateUsersSignal(output);
        Q_EMIT slurmdbV0039UpdateUsersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT slurmdbV0039UpdateUsersSignalE(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateUsersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT slurmdbV0039UpdateUsersSignalError(output, error_type, error_str);
        Q_EMIT slurmdbV0039UpdateUsersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISlurmApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace hm:slurm:client
